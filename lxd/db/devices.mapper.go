//go:build linux && cgo && !agent
// +build linux,cgo,!agent

package db

// The code below was generated by lxd-generate - DO NOT EDIT!

import (
	"fmt"
	"strings"

	"github.com/lxc/lxd/lxd/db/query"
	"github.com/lxc/lxd/shared/api"
)

var _ = api.ServerEnvironment{}

const deviceObjects = `SELECT %s_devices.id, %s_devices.%s_id, %s_devices.name, %s_devices.type
  FROM %s_devices
  ORDER BY %s_devices.name`

const deviceCreate = `INSERT INTO %s_devices (%s_id, name, type)
  VALUES (?, ?, ?)`

const deviceDelete = `DELETE FROM %s_devices WHERE %s_id = ?`

// GetDevices returns all available devices for the parent entity.
// generator: device GetMany
func (c *ClusterTx) GetDevices(parent string) (map[int][]Device, error) {
	var err error

	// Result slice.
	objects := make([]Device, 0)

	deviceObjectsLocal := strings.Replace(deviceObjects, "%s_id", fmt.Sprintf("%s_id", parent), -1)
	fillParent := make([]interface{}, strings.Count(deviceObjectsLocal, "%s"))
	for i := range fillParent {
		fillParent[i] = strings.Replace(parent, "_", "s_", -1) + "s"
	}

	stmt, err := c.prepare(fmt.Sprintf(deviceObjectsLocal, fillParent...))
	if err != nil {
		return nil, err
	}

	args := []interface{}{}

	// Dest function for scanning a row.
	dest := func(i int) []interface{} {
		objects = append(objects, Device{})
		return []interface{}{
			&objects[i].ID,
			&objects[i].ReferenceID,
			&objects[i].Name,
			&objects[i].Type,
		}
	}

	// Select.
	err = query.SelectObjects(stmt, dest, args...)
	if err != nil {
		return nil, fmt.Errorf("Failed to fetch from \"devices\" table: %w", err)
	}

	config, err := c.GetConfig(parent + "_device")
	if err != nil {
		return nil, err
	}

	for i := range objects {
		if _, ok := config[objects[i].ID]; !ok {
			objects[i].Config = map[string]string{}
		} else {
			objects[i].Config = config[objects[i].ID]
		}
	}

	resultMap := map[int][]Device{}
	for _, object := range objects {
		if _, ok := resultMap[object.ReferenceID]; !ok {
			resultMap[object.ReferenceID] = []Device{}
		}
		resultMap[object.ReferenceID] = append(resultMap[object.ReferenceID], object)
	}

	return resultMap, nil
}

// CreateDevice adds a new device to the database.
// generator: device Create
func (c *ClusterTx) CreateDevice(parent string, object Device) error {
	deviceCreateLocal := strings.Replace(deviceCreate, "%s_id", fmt.Sprintf("%s_id", parent), -1)
	fillParent := make([]interface{}, strings.Count(deviceCreateLocal, "%s"))
	for i := range fillParent {
		fillParent[i] = strings.Replace(parent, "_", "s_", -1) + "s"
	}

	stmt, err := c.prepare(fmt.Sprintf(deviceCreateLocal, fillParent...))
	if err != nil {
		return err
	}

	result, err := stmt.Exec(object.ReferenceID, object.Name, object.Type)
	if err != nil {
		return fmt.Errorf("Insert failed for \"%s_devices\" table: %w", parent, err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		return fmt.Errorf("Failed to fetch ID: %w", err)
	}

	referenceID := int(id)
	for key, value := range object.Config {
		insert := Config{
			ReferenceID: referenceID,
			Key:         key,
			Value:       value,
		}

		err = c.CreateConfig(parent+"_device", insert)
		if err != nil {
			return fmt.Errorf("Insert Config failed for Device: %w", err)
		}

	}
	return nil
}

// UpdateDevices updates the device matching the given key parameters.
// generator: device Update
func (c *ClusterTx) UpdateDevices(parent string, referenceID int, devices map[string]Device) error {
	// Delete current entry.
	err := c.DeleteDevices(parent, referenceID)
	if err != nil {
		return err
	}

	// Insert new entries.
	for _, object := range devices {
		object.ReferenceID = referenceID
		err = c.CreateDevice(parent, object)
	}
	if err != nil {
		return err
	}

	return nil
}

// DeleteDevices deletes the device matching the given key parameters.
// generator: device DeleteMany
func (c *ClusterTx) DeleteDevices(parent string, referenceID int) error {
	deviceDeleteLocal := strings.Replace(deviceDelete, "%s_id", fmt.Sprintf("%s_id", parent), -1)
	fillParent := make([]interface{}, strings.Count(deviceDeleteLocal, "%s"))
	for i := range fillParent {
		fillParent[i] = strings.Replace(parent, "_", "s_", -1) + "s"
	}

	stmt, err := c.prepare(fmt.Sprintf(deviceDeleteLocal, fillParent...))
	if err != nil {
		return err
	}

	result, err := stmt.Exec(referenceID)
	if err != nil {
		return fmt.Errorf("Delete entry for \"%s_device\" failed: %w", parent, err)
	}

	_, err = result.RowsAffected()
	if err != nil {
		return fmt.Errorf("Fetch affected rows: %w", err)
	}

	return nil
}
