package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
	"unicode"
)

func main() {
	handleErr := func(err error) {
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(1)
	}

	if len(os.Args) < 2 {
		handleErr(errors.New("In package directory must be provided"))
	}

	if len(os.Args) < 3 {
		handleErr(errors.New("Out file name must be provided"))
	}

	if len(os.Args) > 3 {
		handleErr(errors.New("Unknown additional arguments"))
	}

	info, err := os.Stat(os.Args[1])
	if err != nil {
		handleErr(err)
	}

	if !info.IsDir() {
		handleErr(fmt.Errorf("Package directory does not exist %q", os.Args[1]))
	}

	fset := token.NewFileSet()
	paths, err := filepath.Glob(filepath.Join(os.Args[1], "*.go"))
	if err != nil {
		handleErr(fmt.Errorf("Search source file: %w", err))
	}

	var allSpecs []Spec
	var packageName string
	for _, path := range paths {
		// Skip test files.
		if strings.Contains(path, "_test.go") {
			continue
		}

		file, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			handleErr(fmt.Errorf("Parse Go source file %q: %w", path, err))
		}

		if packageName == "" {
			packageName = file.Name.Name
		}

		fileSpecs, err := getSpecs(file)
		if err != nil {
			handleErr(err)
		}

		allSpecs = append(allSpecs, fileSpecs...)
	}

	var b bytes.Buffer
	b.WriteString("//go:build linux && cgo && !agent\n\n")
	b.WriteString("package " + packageName + "\n\n")
	b.WriteString("// Generated by simplegen - DO NOT EDIT\n")
	for _, spec := range allSpecs {
		err = specTpl.Execute(&b, spec.tplData())
		if err != nil {
			handleErr(err)
		}
	}

	outFile, err := os.Create(filepath.Join(os.Args[1:]...))
	if err != nil {
		handleErr(err)
	}

	_, err = b.WriteTo(outFile)
	if err != nil {
		handleErr(err)
	}
}

func getSpecs(f *ast.File) ([]Spec, error) {
	specs := make([]Spec, 0, len(f.Decls))
	for _, decl := range f.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE || genDecl.Doc == nil || len(genDecl.Doc.List) == 0 || len(genDecl.Specs) != 1 {
			continue
		}

		tableName, ok := strings.CutPrefix(genDecl.Doc.List[len(genDecl.Doc.List)-1].Text, "// db:model ")
		if !ok {
			continue
		}

		newSpec := Spec{
			TableName: tableName,
		}

		typeSpec, ok := genDecl.Specs[0].(*ast.TypeSpec)
		if !ok {
			return nil, fmt.Errorf("Encountered unexpected type spec %q", genDecl.Specs[0])
		}

		newSpec.StructName = typeSpec.Name.Name

		structTypeSpec, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return nil, fmt.Errorf("Encountered unexpected struct type spec %q", genDecl.Specs[0])
		}

		for _, field := range structTypeSpec.Fields.List {
			if field.Tag == nil {
				continue
			}

			newFieldSpec := FieldSpec{
				FieldName: field.Names[0].Name,
			}

			newFieldSpec.ColumnName = reflect.StructTag(strings.Trim(field.Tag.Value, "`")).Get("db")
			if newFieldSpec.ColumnName == "" {
				continue
			}

			column, _, ok := strings.Cut(newFieldSpec.ColumnName, ".")
			if !ok {
				newFieldSpec.ColumnName = tableName + "." + column
			}

			if field.Doc != nil {
				for _, l := range field.Doc.List {
					join, ok := strings.CutPrefix(l.Text, "// db:join ")
					if ok {
						newSpec.Joins = append(newSpec.Joins, join)
						break
					}
				}
			}

			// Hardcode primary key as "id" column, as that is always true in LXD.
			if newFieldSpec.ColumnName == tableName+".id" {
				newSpec.PrimaryKey = newFieldSpec
			}

			newSpec.Fields = append(newSpec.Fields, newFieldSpec)
		}

		if newSpec.PrimaryKey.FieldName == "" {
			return nil, fmt.Errorf("Did not find a primary key for struct %q", newSpec.StructName)
		}

		if len(newSpec.Fields) == 0 {
			return nil, errors.New("Table spec must have at least one field")
		}

		specs = append(specs, newSpec)
	}

	return specs, nil
}

type Spec struct {
	StructName string
	TableName  string
	Fields     []FieldSpec
	PrimaryKey FieldSpec
	Joins      []string
}

func (s *Spec) tplData() map[string]any {
	return map[string]any{
		"receiver":      string(s.Receiver()),
		"structName":    s.StructName,
		"tableName":     s.TableName,
		"backtick":      "`",
		"baseQuery":     s.BaseQuery(),
		"scanColumns":   s.ScanColumns(),
		"scanArgs":      s.ScanArgs(),
		"createColumns": s.CreateColumns(),
		"createValues":  s.CreateValues(),
		"pkColumn":      s.PKColumn(),
		"pkValue":       s.PKValue(),
	}
}

type FieldSpec struct {
	FieldName  string
	ColumnName string
}

var specTpl = template.Must(template.New("spec").Parse(`
// TableName returns the table name for [{{ .structName }}] entities.
func ({{ .receiver }} {{ .structName }}) TableName() string {
	return "{{ .tableName }}"
}

func ({{ .receiver }} {{ .structName }}) ScanColumns() []string {
	return {{ .scanColumns }}
}

// BaseQuery implements [query.BaseQuerier] for [{{ .structName }}].
// Query columns appear in field definition order.
func ({{ .receiver }} {{ .structName }}) BaseQuery() string {
	return {{ .backtick }}{{ .baseQuery }}{{ .backtick }}
}

// ScanArgs implements [query.ScanArger] for [{{ .structName }}].
// This returns references to struct fields in definition order.
func ({{ .receiver }} *{{ .structName }}) ScanArgs() []any {
	return {{ .scanArgs }}
}

// CreateColumns returns the unqualified column names of [{{ .structName }}] entities used during an insert.
func ({{ .receiver }} {{ .structName }}) CreateColumns() []string {
	return {{ .createColumns }}
}

// CreateValues returns a list of values from [{{ .structName }}] entities matching the columns returned from CreateColumns.
func ({{ .receiver }} {{ .structName }}) CreateValues() []any {
	return {{ .createValues }}
}

// PKColumn returns the column name for the primary key of a [{{ .structName }}] entity used during an update.
func ({{ .receiver }} {{ .structName }}) PKColumn() string {
	return {{ .pkColumn }}
}

// PKValue returns the value for the primary key of a [{{ .structName }}] entity used during an update.
func ({{ .receiver }} {{ .structName }}) PKValue() any {
	return {{ .pkValue }}
}
`))

func (s *Spec) Receiver() rune {
	return unicode.ToLower(rune(s.StructName[0]))
}

func (s *Spec) BaseQuery() string {
	var b strings.Builder
	b.WriteString("SELECT\n\t")
	b.WriteString(strings.Join(s.scanCols(), ",\n\t"))
	b.WriteString("\nFROM " + s.TableName + "\n")
	b.WriteString(strings.Join(s.Joins, "\n"))
	return b.String()
}

func (s *Spec) scanCols() []string {
	cols := make([]string, 0, len(s.Fields))
	for _, f := range s.Fields {
		cols = append(cols, f.ColumnName)
	}

	return cols
}

func (s *Spec) ScanColumns() string {
	return "[]string{\n\t\t\"" + strings.Join(s.scanCols(), "\",\n\t\t\"") + "\",\n\t}"
}

func (s *Spec) CreateColumns() string {
	cols := make([]string, 0, len(s.Fields))
	for _, f := range s.Fields {
		unqualifiedColName, ok := strings.CutPrefix(f.ColumnName, s.TableName+".")
		if !ok {
			continue
		}

		if f == s.PrimaryKey {
			continue
		}

		cols = append(cols, fmt.Sprintf("%q", unqualifiedColName))
	}

	return "[]string{" + strings.Join(cols, ", ") + "}"
}

func (s *Spec) CreateValues() string {
	values := make([]string, 0, len(s.Fields))
	for _, f := range s.Fields {
		if !strings.HasPrefix(f.ColumnName, s.TableName+".") {
			continue
		}

		if f == s.PrimaryKey {
			continue
		}

		values = append(values, string(s.Receiver())+"."+f.FieldName)
	}

	return "[]any{" + strings.Join(values, ", ") + "}"
}

func (s *Spec) PKColumn() string {
	return `"` + strings.TrimPrefix(s.PrimaryKey.ColumnName, s.TableName+".") + `"`
}

func (s *Spec) PKValue() string {
	return string(s.Receiver()) + "." + s.PrimaryKey.FieldName
}

func (s *Spec) ScanArgs() string {
	scanArgs := make([]string, 0, len(s.Fields))
	for _, f := range s.Fields {
		scanArgs = append(scanArgs, "&"+string(s.Receiver())+"."+f.FieldName)
	}

	return "[]any{" + strings.Join(scanArgs, ", ") + "}"
}
