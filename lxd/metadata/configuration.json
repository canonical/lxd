{
	"configs": {
		"cluster": {
			"cluster": {
				"keys": [
					{
						"scheduler.instance": {
							"defaultdesc": "`all`",
							"longdesc": "Possible values are `all`, `manual`, and `group`. See\n{ref}`clustering-instance-placement` for more information.",
							"shortdesc": "Controls how instances are scheduled to run on this member",
							"type": "string"
						}
					},
					{
						"user.*": {
							"longdesc": "User keys can be used in search.",
							"shortdesc": "Free form user key/value storage",
							"type": "string"
						}
					}
				]
			}
		},
		"device-disk": {
			"device-conf": {
				"keys": [
					{
						"boot.priority": {
							"condition": "virtual machine",
							"longdesc": "A higher value indicates a higher boot precedence for the disk device.\nThis is useful for prioritizing boot sources like ISO-backed disks.",
							"required": "no",
							"shortdesc": "Boot priority for VMs",
							"type": "integer"
						}
					},
					{
						"ceph.cluster_name": {
							"defaultdesc": "`ceph`",
							"longdesc": "",
							"required": "for Ceph or CephFS sources",
							"shortdesc": "Cluster name of the Ceph cluster",
							"type": "string"
						}
					},
					{
						"ceph.user_name": {
							"defaultdesc": "`admin`",
							"longdesc": "",
							"required": "for Ceph or CephFS sources",
							"shortdesc": "User name of the Ceph cluster",
							"type": "string"
						}
					},
					{
						"initial.*": {
							"longdesc": "Initial volume configuration allows setting unique configurations independent of the default storage pool settings.\nSee {ref}`devices-disk-initial-config` for more information.",
							"required": "no",
							"shortdesc": "Initial volume configuration",
							"type": "n/a"
						}
					},
					{
						"io.bus": {
							"condition": "virtual machine",
							"defaultdesc": "`virtio-scsi`",
							"longdesc": "Possible values are `virtio-scsi`, `virtio-blk` or `nvme`.",
							"required": "no",
							"shortdesc": "Bus for the device",
							"type": "string"
						}
					},
					{
						"io.cache": {
							"condition": "virtual machine",
							"defaultdesc": "`none`",
							"longdesc": "Possible values are `none`, `writeback`, or `unsafe`.",
							"required": "no",
							"shortdesc": "Caching mode for the device",
							"type": "string"
						}
					},
					{
						"limits.max": {
							"longdesc": "This option is the same as setting both {config:option}`device-disk-device-conf:limits.read` and {config:option}`device-disk-device-conf:limits.write`.\n\nYou can specify a value in byte/s (various suffixes supported, see {ref}`instances-limit-units`) or in IOPS (must be suffixed with `iops`).\nSee also {ref}`storage-configure-io`.\n",
							"required": "no",
							"shortdesc": "I/O limit in byte/s or IOPS for both read and write",
							"type": "string"
						}
					},
					{
						"limits.read": {
							"longdesc": "You can specify a value in byte/s (various suffixes supported, see {ref}`instances-limit-units`) or in IOPS (must be suffixed with `iops`).\nSee also {ref}`storage-configure-io`.",
							"required": "no",
							"shortdesc": "Read I/O limit in byte/s or IOPS",
							"type": "string"
						}
					},
					{
						"limits.write": {
							"longdesc": "You can specify a value in byte/s (various suffixes supported, see {ref}`instances-limit-units`) or in IOPS (must be suffixed with `iops`).\nSee also {ref}`storage-configure-io`.",
							"required": "no",
							"shortdesc": "Write I/O limit in byte/s or IOPS",
							"type": "string"
						}
					},
					{
						"path": {
							"condition": "container",
							"longdesc": "This option specifies the path inside the container where the disk will be mounted.",
							"required": "yes",
							"shortdesc": "Mount path",
							"type": "string"
						}
					},
					{
						"pool": {
							"condition": "storage volumes managed by LXD",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Storage pool to which the disk device belongs",
							"type": "string"
						}
					},
					{
						"propagation": {
							"defaultdesc": "`private`",
							"longdesc": "Possible values are `private` (the default), `shared`, `slave`, `unbindable`, `rshared`, `rslave`, `runbindable`, `rprivate`.\nSee the Linux Kernel [shared subtree](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt) documentation for a full explanation.\n",
							"required": "no",
							"shortdesc": "How a bind-mount is shared between the instance and the host",
							"type": "string"
						}
					},
					{
						"raw.mount.options": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "File system specific mount options",
							"type": "string"
						}
					},
					{
						"readonly": {
							"defaultdesc": "`false`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Whether to make the mount read-only",
							"type": "bool"
						}
					},
					{
						"recursive": {
							"defaultdesc": "`false`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Whether to recursively mount the source path",
							"type": "bool"
						}
					},
					{
						"required": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Whether to fail if the source doesnâ€™t exist",
							"type": "bool"
						}
					},
					{
						"shift": {
							"condition": "container",
							"defaultdesc": "`false`",
							"longdesc": "If enabled, this option sets up a shifting overlay to translate the source UID/GID to match the container instance.",
							"required": "no",
							"shortdesc": "Whether to set up a UID/GID shifting overlay",
							"type": "bool"
						}
					},
					{
						"size": {
							"longdesc": "This option is supported only for the rootfs (`/`).\n\nSpecify a value in bytes (various suffixes supported, see {ref}`instances-limit-units`).",
							"required": "no",
							"shortdesc": "Disk size",
							"type": "string"
						}
					},
					{
						"size.state": {
							"condition": "virtual machine",
							"longdesc": "This option is similar to {config:option}`device-disk-device-conf:size`, but applies to the file-system volume used for saving the runtime state in VMs.",
							"required": "no",
							"shortdesc": "Size of the file-system volume used for saving runtime state",
							"type": "string"
						}
					},
					{
						"source": {
							"longdesc": "See {ref}`devices-disk-types` for details.\n",
							"required": "yes",
							"shortdesc": "Source of a file system or block device",
							"type": "string"
						}
					}
				]
			}
		},
		"device-gpu-mdev": {
			"device-conf": {
				"keys": [
					{
						"id": {
							"longdesc": "",
							"shortdesc": "DRM card ID of the GPU device",
							"type": "string"
						}
					},
					{
						"mdev": {
							"defaultdesc": "`0`",
							"longdesc": "For example: `i915-GVTg_V5_4`",
							"required": "yes",
							"shortdesc": "The `mdev` profile to use",
							"type": "string"
						}
					},
					{
						"pci": {
							"longdesc": "",
							"shortdesc": "PCI address of the GPU device",
							"type": "string"
						}
					},
					{
						"productid": {
							"longdesc": "",
							"shortdesc": "Product ID of the GPU device",
							"type": "string"
						}
					},
					{
						"vendorid": {
							"longdesc": "",
							"shortdesc": "Vendor ID of the GPU device",
							"type": "string"
						}
					}
				]
			}
		},
		"device-gpu-mig": {
			"device-conf": {
				"keys": [
					{
						"id": {
							"longdesc": "",
							"shortdesc": "DRM card ID of the GPU device",
							"type": "string"
						}
					},
					{
						"mig.ci": {
							"longdesc": "",
							"shortdesc": "Existing MIG compute instance ID",
							"type": "integer"
						}
					},
					{
						"mig.gi": {
							"longdesc": "",
							"shortdesc": "Existing MIG GPU instance ID",
							"type": "integer"
						}
					},
					{
						"mig.uuid": {
							"longdesc": "You can omit the `MIG-` prefix when specifying this option.",
							"shortdesc": "Existing MIG device UUID",
							"type": "string"
						}
					},
					{
						"pci": {
							"longdesc": "",
							"shortdesc": "PCI address of the GPU device",
							"type": "string"
						}
					},
					{
						"productid": {
							"longdesc": "",
							"shortdesc": "Product ID of the GPU device",
							"type": "string"
						}
					},
					{
						"vendorid": {
							"longdesc": "",
							"shortdesc": "Vendor ID of the GPU device",
							"type": "string"
						}
					}
				]
			}
		},
		"device-gpu-physical": {
			"device-conf": {
				"keys": [
					{
						"gid": {
							"condition": "container",
							"defaultdesc": "`0`",
							"longdesc": "",
							"shortdesc": "GID of the device owner in the container",
							"type": "integer"
						}
					},
					{
						"id": {
							"longdesc": "The ID can either be the DRM card ID of the GPU device (container or VM) or a fully-qualified Container Device Interface (CDI) name (container only).\nHere are some examples of fully-qualified CDI names:\n\n- `nvidia.com/gpu=0`: Instructs LXD to operate a discrete GPU (dGPU) pass-through of brand NVIDIA with the first discovered GPU on your system. You can use the `nvidia-smi` tool on your host to find out which identifier to use.\n- `nvidia.com/gpu=1833c8b5-9aa0-5382-b784-68b7e77eb185`: Instructs LXD to operate a discrete GPU (dGPU) pass-through of brand NVIDIA with a given GPU unique identifier. This identifier should also appear with `nvidia-smi -L`.\n- `nvidia.com/igpu=all`: Instructs LXD to pass all the host integrated GPUs (iGPU) of brand NVIDIA. The concept of an index does not currently map to iGPUs. It is possible to list them with the `nvidia-smi -L` command. A special `nvgpu` mention should appear in the generated list to indicate a device to be an iGPU.\n- `nvidia.com/gpu=all`: Instructs LXD to pass all the host GPUs of brand NVIDIA through to the container.",
							"shortdesc": "ID of the GPU device",
							"type": "string"
						}
					},
					{
						"mode": {
							"condition": "container",
							"defaultdesc": "`0660`",
							"longdesc": "",
							"shortdesc": "Mode of the device in the container",
							"type": "integer"
						}
					},
					{
						"pci": {
							"longdesc": "",
							"shortdesc": "PCI address of the GPU device",
							"type": "string"
						}
					},
					{
						"productid": {
							"longdesc": "",
							"shortdesc": "Product ID of the GPU device",
							"type": "string"
						}
					},
					{
						"uid": {
							"condition": "container",
							"defaultdesc": "`0`",
							"longdesc": "",
							"shortdesc": "UID of the device owner in the container",
							"type": "integer"
						}
					},
					{
						"vendorid": {
							"longdesc": "",
							"shortdesc": "Vendor ID of the GPU device",
							"type": "string"
						}
					}
				]
			}
		},
		"device-gpu-sriov": {
			"device-conf": {
				"keys": [
					{
						"id": {
							"longdesc": "",
							"shortdesc": "DRM card ID of the parent GPU device",
							"type": "string"
						}
					},
					{
						"pci": {
							"longdesc": "",
							"shortdesc": "PCI address of the parent GPU device",
							"type": "string"
						}
					},
					{
						"productid": {
							"longdesc": "",
							"shortdesc": "Product ID of the parent GPU device",
							"type": "string"
						}
					},
					{
						"vendorid": {
							"longdesc": "",
							"shortdesc": "Vendor ID of the parent GPU device",
							"type": "string"
						}
					}
				]
			}
		},
		"device-infiniband": {
			"device-conf": {
				"keys": [
					{
						"hwaddr": {
							"defaultdesc": "randomly assigned",
							"longdesc": " You can specify either the full 20-byte variant or the short 8-byte variant (which will modify only the last 8 bytes of the parent device).",
							"required": "no",
							"shortdesc": "MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"mtu": {
							"defaultdesc": "parent MTU",
							"longdesc": "",
							"required": "no",
							"shortdesc": "MTU of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"defaultdesc": "kernel assigned",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"nictype": {
							"longdesc": "Possible values are `physical` and `sriov`.",
							"required": "yes",
							"shortdesc": "Device type",
							"type": "string"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "The name of the host device or bridge",
							"type": "string"
						}
					}
				]
			}
		},
		"device-nic-bridged": {
			"device-conf": {
				"keys": [
					{
						"boot.priority": {
							"longdesc": "A higher value for this option means that the VM boots first.",
							"managed": "no",
							"shortdesc": "Boot priority for VMs",
							"type": "integer"
						}
					},
					{
						"host_name": {
							"defaultdesc": "randomly assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Name of the interface inside the host",
							"type": "string"
						}
					},
					{
						"hwaddr": {
							"defaultdesc": "randomly assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"ipv4.address": {
							"longdesc": "Set this option to `none` to restrict all IPv4 traffic when {config:option}`device-nic-bridged-device-conf:security.ipv4_filtering` is set.",
							"managed": "no",
							"shortdesc": "IPv4 address to assign to the instance through DHCP",
							"type": "string"
						}
					},
					{
						"ipv4.routes": {
							"longdesc": "Specify a comma-delimited list of IPv4 static routes for this NIC to add on the host.",
							"managed": "no",
							"shortdesc": "IPv4 static routes for the NIC to add on the host",
							"type": "string"
						}
					},
					{
						"ipv4.routes.external": {
							"longdesc": "Specify a comma-delimited list of IPv4 static routes to route to the NIC and publish on the uplink network (BGP).",
							"managed": "no",
							"shortdesc": "IPv4 static routes to route to NIC",
							"type": "string"
						}
					},
					{
						"ipv6.address": {
							"longdesc": "Set this option to `none` to restrict all IPv6 traffic when {config:option}`device-nic-bridged-device-conf:security.ipv6_filtering` is set.",
							"managed": "no",
							"shortdesc": "IPv6 address to assign to the instance through DHCP",
							"type": "string"
						}
					},
					{
						"ipv6.routes": {
							"longdesc": "Specify a comma-delimited list of IPv6 static routes for this NIC to add on the host.",
							"managed": "no",
							"shortdesc": "IPv6 static routes for the NIC to add on the host",
							"type": "string"
						}
					},
					{
						"ipv6.routes.external": {
							"longdesc": "Specify a comma-delimited list of IPv6 static routes to route to the NIC and publish on the uplink network (BGP).",
							"managed": "no",
							"shortdesc": "IPv6 static routes to route to NIC",
							"type": "string"
						}
					},
					{
						"limits.egress": {
							"longdesc": "Specify the limit in bit/s. Various suffixes are supported (see {ref}`instances-limit-units`).",
							"managed": "no",
							"shortdesc": "I/O limit for outgoing traffic",
							"type": "string"
						}
					},
					{
						"limits.ingress": {
							"longdesc": "Specify the limit in bit/s. Various suffixes are supported (see {ref}`instances-limit-units`).",
							"managed": "no",
							"shortdesc": "I/O limit for incoming traffic",
							"type": "string"
						}
					},
					{
						"limits.max": {
							"longdesc": "This option is the same as setting both {config:option}`device-nic-bridged-device-conf:limits.ingress` and {config:option}`device-nic-bridged-device-conf:limits.egress`.\n\nSpecify the limit in bit/s. Various suffixes are supported (see {ref}`instances-limit-units`).",
							"managed": "no",
							"shortdesc": "I/O limit for both incoming and outgoing traffic",
							"type": "string"
						}
					},
					{
						"limits.priority": {
							"longdesc": "The `skb-\u003epriority` value for outgoing traffic is used by the kernel queuing discipline (qdisc) to prioritize network packets.\nSpecify the value as a 32-bit unsigned integer.\n\nThe effect of this value depends on the particular qdisc implementation, for example, `SKBPRIO` or `QFQ`.\nConsult the kernel qdisc documentation before setting this value.",
							"managed": "no",
							"shortdesc": "`skb-\u003epriority` value for outgoing traffic",
							"type": "integer"
						}
					},
					{
						"maas.subnet.ipv4": {
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "MAAS IPv4 subnet to register the instance in",
							"type": "string"
						}
					},
					{
						"maas.subnet.ipv6": {
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "MAAS IPv6 subnet to register the instance in",
							"type": "string"
						}
					},
					{
						"mtu": {
							"defaultdesc": "parent MTU",
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "MTU of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"defaultdesc": "kernel assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"network": {
							"longdesc": "You can specify this option instead of specifying the `nictype` directly.",
							"managed": "no",
							"shortdesc": "Managed network to link the device to",
							"type": "string"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"managed": "yes",
							"required": "if specifying the `nictype` directly",
							"shortdesc": "Name of the host device",
							"type": "string"
						}
					},
					{
						"queue.tx.length": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Transmit queue length for the NIC",
							"type": "integer"
						}
					},
					{
						"security.ipv4_filtering": {
							"defaultdesc": "`false`",
							"longdesc": "Set this option to `true` to prevent the instance from spoofing another instanceâ€™s IPv4 address.\nThis option enables {config:option}`device-nic-bridged-device-conf:security.mac_filtering`.",
							"managed": "no",
							"shortdesc": "Whether to prevent the instance from spoofing an IPv4 address",
							"type": "bool"
						}
					},
					{
						"security.ipv6_filtering": {
							"defaultdesc": "`false`",
							"longdesc": "Set this option to `true` to prevent the instance from spoofing another instanceâ€™s IPv6 address.\nThis option enables {config:option}`device-nic-bridged-device-conf:security.mac_filtering`.",
							"managed": "no",
							"shortdesc": "Whether to prevent the instance from spoofing an IPv6 address",
							"type": "bool"
						}
					},
					{
						"security.mac_filtering": {
							"defaultdesc": "`false`",
							"longdesc": "Set this option to `true` to prevent the instance from spoofing another instanceâ€™s MAC address.",
							"managed": "no",
							"shortdesc": "Whether to prevent the instance from spoofing a MAC address",
							"type": "bool"
						}
					},
					{
						"security.port_isolation": {
							"defaultdesc": "`false`",
							"longdesc": "Set this option to `true` to prevent the NIC from communicating with other NICs in the network that have port isolation enabled.",
							"managed": "no",
							"shortdesc": "Whether to respect port isolation",
							"type": "bool"
						}
					},
					{
						"vlan": {
							"longdesc": "Set this option to `none` to remove the port from the default VLAN.",
							"managed": "no",
							"shortdesc": "VLAN ID to use for non-tagged traffic",
							"type": "integer"
						}
					},
					{
						"vlan.tagged": {
							"longdesc": "Specify the VLAN IDs or ranges as a comma-delimited list.",
							"managed": "no",
							"shortdesc": "VLAN IDs or VLAN ranges to join for tagged traffic",
							"type": "integer"
						}
					}
				]
			}
		},
		"device-nic-ipvlan": {
			"device-conf": {
				"keys": [
					{
						"gvrp": {
							"defaultdesc": "`false`",
							"longdesc": "This option specifies whether to register the VLAN using the GARP VLAN Registration Protocol.",
							"shortdesc": "Whether to use GARP VLAN Registration Protocol",
							"type": "bool"
						}
					},
					{
						"hwaddr": {
							"defaultdesc": "randomly assigned",
							"longdesc": "",
							"shortdesc": "MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"ipv4.address": {
							"longdesc": "Specify a comma-delimited list of IPv4 static addresses to add to the instance.\nIn `l2` mode, you can specify them as CIDR values or singular addresses using a subnet of `/24`.",
							"shortdesc": "IPv4 static addresses to add to the instance",
							"type": "string"
						}
					},
					{
						"ipv4.gateway": {
							"defaultdesc": "`auto` (`l3s`), `-` (`l2`)",
							"longdesc": "In `l3s` mode, the option specifies whether to add an automatic default IPv4 gateway.\nPossible values are `auto` and `none`.\n\nIn `l2` mode, this option specifies the IPv4 address of the gateway.",
							"shortdesc": "IPv4 gateway",
							"type": "string"
						}
					},
					{
						"ipv4.host_table": {
							"longdesc": "The custom policy routing table is in addition to the main routing table.",
							"shortdesc": "Custom policy routing table ID to add IPv4 static routes to",
							"type": "integer"
						}
					},
					{
						"ipv6.address": {
							"longdesc": "Specify a comma-delimited list of IPv6 static addresses to add to the instance.\nIn `l2` mode, you can specify them as CIDR values or singular addresses using a subnet of `/64`.",
							"shortdesc": "IPv6 static addresses to add to the instance",
							"type": "string"
						}
					},
					{
						"ipv6.gateway": {
							"defaultdesc": "`auto` (`l3s`), `-` (`l2`)",
							"longdesc": "In `l3s` mode, the option specifies whether to add an automatic default IPv6 gateway.\nPossible values are `auto` and `none`.\n\nIn `l2` mode, this option specifies the IPv6 address of the gateway.",
							"shortdesc": "IPv6 gateway",
							"type": "string"
						}
					},
					{
						"ipv6.host_table": {
							"longdesc": "The custom policy routing table is in addition to the main routing table.",
							"shortdesc": "Custom policy routing table ID to add IPv6 static routes to",
							"type": "integer"
						}
					},
					{
						"mode": {
							"defaultdesc": "`l3s`",
							"longdesc": "Possible values are `l2` and `l3s`.",
							"shortdesc": "IPVLAN mode",
							"type": "string"
						}
					},
					{
						"mtu": {
							"defaultdesc": "parent MTU",
							"longdesc": "",
							"shortdesc": "The MTU of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"defaultdesc": "kernel assigned",
							"longdesc": "",
							"shortdesc": "Name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "Name of the host device",
							"type": "string"
						}
					},
					{
						"vlan": {
							"longdesc": "",
							"shortdesc": "VLAN ID to attach to",
							"type": "integer"
						}
					}
				]
			}
		},
		"device-nic-macvlan": {
			"device-conf": {
				"keys": [
					{
						"boot.priority": {
							"longdesc": "A higher value for this option means that the VM boots first.",
							"managed": "no",
							"shortdesc": "Boot priority for VMs",
							"type": "integer"
						}
					},
					{
						"gvrp": {
							"defaultdesc": "`false`",
							"longdesc": "This option specifies whether to register the VLAN using the GARP VLAN Registration Protocol.",
							"managed": "no",
							"shortdesc": "Whether to use GARP VLAN Registration Protocol",
							"type": "bool"
						}
					},
					{
						"hwaddr": {
							"defaultdesc": "randomly assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"maas.subnet.ipv4": {
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "MAAS IPv4 subnet to register the instance in",
							"type": "string"
						}
					},
					{
						"maas.subnet.ipv6": {
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "MAAS IPv6 subnet to register the instance in",
							"type": "string"
						}
					},
					{
						"mtu": {
							"defaultdesc": "parent MTU",
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "MTU of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"defaultdesc": "kernel assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"network": {
							"longdesc": "You can specify this option instead of specifying the `nictype` directly.",
							"managed": "no",
							"shortdesc": "Managed network to link the device to",
							"type": "string"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"managed": "yes",
							"required": "if specifying the `nictype` directly",
							"shortdesc": "Name of the host device",
							"type": "string"
						}
					},
					{
						"vlan": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "VLAN ID to attach to",
							"type": "integer"
						}
					}
				]
			}
		},
		"device-nic-ovn": {
			"device-conf": {
				"keys": [
					{
						"acceleration": {
							"defaultdesc": "`none`",
							"longdesc": "Possible values are `none`, `sriov`, or `vdpa`.\nSee {ref}`devices-nic-hw-acceleration` for more information.",
							"managed": "no",
							"shortdesc": "Enable hardware offloading",
							"type": "string"
						}
					},
					{
						"boot.priority": {
							"longdesc": "A higher value for this option means that the VM boots first.",
							"managed": "no",
							"shortdesc": "Boot priority for VMs",
							"type": "integer"
						}
					},
					{
						"host_name": {
							"defaultdesc": "randomly assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Name of the interface inside the host",
							"type": "string"
						}
					},
					{
						"hwaddr": {
							"defaultdesc": "randomly assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"ipv4.address": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "IPv4 address to assign to the instance through DHCP",
							"type": "string"
						}
					},
					{
						"ipv4.routes": {
							"longdesc": "Specify a comma-delimited list of IPv4 static routes to route for this NIC.",
							"managed": "no",
							"shortdesc": "IPv4 static routes to route for the NIC",
							"type": "string"
						}
					},
					{
						"ipv4.routes.external": {
							"longdesc": "Specify a comma-delimited list of IPv4 static routes to route to the NIC and publish on the uplink network.",
							"managed": "no",
							"shortdesc": "IPv4 static routes to route to NIC",
							"type": "string"
						}
					},
					{
						"ipv6.address": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "IPv6 address to assign to the instance through DHCP",
							"type": "string"
						}
					},
					{
						"ipv6.routes": {
							"longdesc": "Specify a comma-delimited list of IPv6 static routes to route to the NIC.",
							"managed": "no",
							"shortdesc": "IPv6 static routes to route to the NIC",
							"type": "string"
						}
					},
					{
						"ipv6.routes.external": {
							"longdesc": "Specify a comma-delimited list of IPv6 static routes to route to the NIC and publish on the uplink network.",
							"managed": "no",
							"shortdesc": "IPv6 static routes to route to NIC",
							"type": "string"
						}
					},
					{
						"name": {
							"defaultdesc": "kernel assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"nested": {
							"longdesc": "See also {config:option}`device-nic-ovn-device-conf:vlan`.",
							"managed": "no",
							"shortdesc": "Parent NIC name to nest this NIC under",
							"type": "string"
						}
					},
					{
						"network": {
							"longdesc": "",
							"managed": "yes",
							"required": "yes",
							"shortdesc": "Managed network to link the device to",
							"type": "string"
						}
					},
					{
						"security.acls": {
							"longdesc": "Specify a comma-separated list",
							"managed": "no",
							"shortdesc": "Network ACLs to apply",
							"type": "string"
						}
					},
					{
						"security.acls.default.egress.action": {
							"defaultdesc": "`reject`",
							"longdesc": "The specified action is used for all egress traffic that doesnâ€™t match any ACL rule.",
							"managed": "no",
							"shortdesc": "Default action to use for egress traffic",
							"type": "string"
						}
					},
					{
						"security.acls.default.egress.logged": {
							"defaultdesc": "`false`",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Whether to log egress traffic that doesnâ€™t match any ACL rule",
							"type": "bool"
						}
					},
					{
						"security.acls.default.ingress.action": {
							"defaultdesc": "`reject`",
							"longdesc": "The specified action is used for all ingress traffic that doesnâ€™t match any ACL rule.",
							"managed": "no",
							"shortdesc": "Default action to use for ingress traffic",
							"type": "string"
						}
					},
					{
						"security.acls.default.ingress.logged": {
							"defaultdesc": "`false`",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Whether to log ingress traffic that doesnâ€™t match any ACL rule",
							"type": "bool"
						}
					},
					{
						"vlan": {
							"longdesc": "See also {config:option}`device-nic-ovn-device-conf:nested`.",
							"managed": "no",
							"shortdesc": "VLAN ID to use when nesting",
							"type": "integer"
						}
					}
				]
			}
		},
		"device-nic-p2p": {
			"device-conf": {
				"keys": [
					{
						"boot.priority": {
							"longdesc": "A higher value for this option means that the VM boots first.",
							"shortdesc": "Boot priority for VMs",
							"type": "integer"
						}
					},
					{
						"host_name": {
							"defaultdesc": "randomly assigned",
							"longdesc": "",
							"shortdesc": "Name of the interface inside the host",
							"type": "string"
						}
					},
					{
						"hwaddr": {
							"defaultdesc": "randomly assigned",
							"longdesc": "",
							"shortdesc": "MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"ipv4.routes": {
							"longdesc": "Specify a comma-delimited list of IPv4 static routes for this NIC to add on the host.",
							"shortdesc": "IPv4 static routes for the NIC to add on the host",
							"type": "string"
						}
					},
					{
						"ipv6.routes": {
							"longdesc": "Specify a comma-delimited list of IPv6 static routes for this NIC to add on the host.",
							"shortdesc": "IPv6 static routes for the NIC to add on the host",
							"type": "string"
						}
					},
					{
						"limits.egress": {
							"longdesc": "Specify the limit in bit/s. Various suffixes are supported (see {ref}`instances-limit-units`).",
							"shortdesc": "I/O limit for outgoing traffic",
							"type": "string"
						}
					},
					{
						"limits.ingress": {
							"longdesc": "Specify the limit in bit/s. Various suffixes are supported (see {ref}`instances-limit-units`).",
							"shortdesc": "I/O limit for incoming traffic",
							"type": "string"
						}
					},
					{
						"limits.max": {
							"longdesc": "This option is the same as setting both {config:option}`device-nic-bridged-device-conf:limits.ingress` and {config:option}`device-nic-bridged-device-conf:limits.egress`.\n\nSpecify the limit in bit/s. Various suffixes are supported (see {ref}`instances-limit-units`).",
							"shortdesc": "I/O limit for both incoming and outgoing traffic",
							"type": "string"
						}
					},
					{
						"limits.priority": {
							"longdesc": "The `skb-\u003epriority` value for outgoing traffic is used by the kernel queuing discipline (qdisc) to prioritize network packets.\nSpecify the value as a 32-bit unsigned integer.\n\nThe effect of this value depends on the particular qdisc implementation, for example, `SKBPRIO` or `QFQ`.\nConsult the kernel qdisc documentation before setting this value.",
							"shortdesc": "`skb-\u003epriority` value for outgoing traffic",
							"type": "integer"
						}
					},
					{
						"mtu": {
							"defaultdesc": "kernel assigned",
							"longdesc": "",
							"shortdesc": "MTU of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"defaultdesc": "kernel assigned",
							"longdesc": "",
							"shortdesc": "Name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"queue.tx.length": {
							"longdesc": "",
							"shortdesc": "Transmit queue length for the NIC",
							"type": "integer"
						}
					}
				]
			}
		},
		"device-nic-physical": {
			"device-conf": {
				"keys": [
					{
						"boot.priority": {
							"longdesc": "A higher value for this option means that the VM boots first.",
							"managed": "no",
							"shortdesc": "Boot priority for VMs",
							"type": "integer"
						}
					},
					{
						"gvrp": {
							"defaultdesc": "`false`",
							"longdesc": "This option specifies whether to register the VLAN using the GARP VLAN Registration Protocol.",
							"managed": "no",
							"shortdesc": "Whether to use GARP VLAN Registration Protocol",
							"type": "bool"
						}
					},
					{
						"hwaddr": {
							"defaultdesc": "randomly assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"maas.subnet.ipv4": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "MAAS IPv4 subnet to register the instance in",
							"type": "string"
						}
					},
					{
						"maas.subnet.ipv6": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "MAAS IPv6 subnet to register the instance in",
							"type": "string"
						}
					},
					{
						"mtu": {
							"defaultdesc": "parent MTU",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "MTU of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"defaultdesc": "kernel assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"network": {
							"longdesc": "You can specify this option instead of specifying the `nictype` directly.",
							"managed": "no",
							"shortdesc": "Managed network to link the device to",
							"type": "string"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"managed": "yes",
							"required": "if specifying the `nictype` directly",
							"shortdesc": "Name of the host device",
							"type": "string"
						}
					},
					{
						"vlan": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "VLAN ID to attach to",
							"type": "integer"
						}
					}
				]
			}
		},
		"device-nic-routed": {
			"device-conf": {
				"keys": [
					{
						"gvrp": {
							"defaultdesc": "`false`",
							"longdesc": "This option specifies whether to register the VLAN using the GARP VLAN Registration Protocol.",
							"shortdesc": "Whether to use GARP VLAN Registration Protocol",
							"type": "bool"
						}
					},
					{
						"host_name": {
							"defaultdesc": "randomly assigned",
							"longdesc": "",
							"shortdesc": "Name of the interface inside the host",
							"type": "string"
						}
					},
					{
						"hwaddr": {
							"defaultdesc": "randomly assigned",
							"longdesc": "",
							"shortdesc": "MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"ipv4.address": {
							"longdesc": "Specify a comma-delimited list of IPv4 static addresses to add to the instance.",
							"shortdesc": "IPv4 static addresses to add to the instance",
							"type": "string"
						}
					},
					{
						"ipv4.gateway": {
							"defaultdesc": "`auto`",
							"longdesc": "Possible values are `auto` and `none`.",
							"shortdesc": "Whether to add an automatic default IPv4 gateway",
							"type": "string"
						}
					},
					{
						"ipv4.host_address": {
							"defaultdesc": "`169.254.0.1`",
							"longdesc": "",
							"shortdesc": "IPv4 address to add to the host-side `veth` interface",
							"type": "string"
						}
					},
					{
						"ipv4.host_table": {
							"longdesc": "The custom policy routing table is in addition to the main routing table.",
							"shortdesc": "Custom policy routing table ID to add IPv4 static routes to",
							"type": "integer"
						}
					},
					{
						"ipv4.neighbor_probe": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to probe the parent network for IPv4 address availability",
							"type": "bool"
						}
					},
					{
						"ipv4.routes": {
							"longdesc": "Specify a comma-delimited list of IPv4 static routes for this NIC to add on the host (without L2 ARP/NDP proxy).",
							"shortdesc": "IPv4 static routes for the NIC to add on the host",
							"type": "string"
						}
					},
					{
						"ipv6.address": {
							"longdesc": "Specify a comma-delimited list of IPv6 static addresses to add to the instance.",
							"shortdesc": "IPv6 static addresses to add to the instance",
							"type": "string"
						}
					},
					{
						"ipv6.gateway": {
							"defaultdesc": "`auto`",
							"longdesc": "Possible values are `auto` and `none`.",
							"shortdesc": "Whether to add an automatic default IPv6 gateway",
							"type": "string"
						}
					},
					{
						"ipv6.host_address": {
							"defaultdesc": "`fe80::1`",
							"longdesc": "",
							"shortdesc": "IPv6 address to add to the host-side `veth` interface",
							"type": "string"
						}
					},
					{
						"ipv6.host_table": {
							"longdesc": "The custom policy routing table is in addition to the main routing table.",
							"shortdesc": "Custom policy routing table ID to add IPv6 static routes to",
							"type": "integer"
						}
					},
					{
						"ipv6.neighbor_probe": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to probe the parent network for IPv6 address availability",
							"type": "bool"
						}
					},
					{
						"ipv6.routes": {
							"longdesc": "Specify a comma-delimited list of IPv6 static routes for this NIC to add on the host (without L2 ARP/NDP proxy).",
							"shortdesc": "IPv6 static routes for the NIC to add on the host",
							"type": "string"
						}
					},
					{
						"limits.egress": {
							"longdesc": "Specify the limit in bit/s. Various suffixes are supported (see {ref}`instances-limit-units`).",
							"shortdesc": "I/O limit for outgoing traffic",
							"type": "string"
						}
					},
					{
						"limits.ingress": {
							"longdesc": "Specify the limit in bit/s. Various suffixes are supported (see {ref}`instances-limit-units`).",
							"shortdesc": "I/O limit for incoming traffic",
							"type": "string"
						}
					},
					{
						"limits.max": {
							"longdesc": "This option is the same as setting both {config:option}`device-nic-bridged-device-conf:limits.ingress` and {config:option}`device-nic-bridged-device-conf:limits.egress`.\n\nSpecify the limit in bit/s. Various suffixes are supported (see {ref}`instances-limit-units`).",
							"shortdesc": "I/O limit for both incoming and outgoing traffic",
							"type": "string"
						}
					},
					{
						"limits.priority": {
							"longdesc": "The `skb-\u003epriority` value for outgoing traffic is used by the kernel queuing discipline (qdisc) to prioritize network packets.\nSpecify the value as a 32-bit unsigned integer.\n\nThe effect of this value depends on the particular qdisc implementation, for example, `SKBPRIO` or `QFQ`.\nConsult the kernel qdisc documentation before setting this value.",
							"shortdesc": "`skb-\u003epriority` value for outgoing traffic",
							"type": "integer"
						}
					},
					{
						"mtu": {
							"defaultdesc": "parent MTU",
							"longdesc": "",
							"shortdesc": "The MTU of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"defaultdesc": "kernel assigned",
							"longdesc": "",
							"shortdesc": "Name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"shortdesc": "Name of the host device to join the instance to",
							"type": "string"
						}
					},
					{
						"queue.tx.length": {
							"longdesc": "",
							"shortdesc": "Transmit queue length for the NIC",
							"type": "integer"
						}
					},
					{
						"vlan": {
							"longdesc": "",
							"shortdesc": "VLAN ID to attach to",
							"type": "integer"
						}
					}
				]
			}
		},
		"device-nic-sriov": {
			"device-conf": {
				"keys": [
					{
						"boot.priority": {
							"longdesc": "A higher value for this option means that the VM boots first.",
							"managed": "no",
							"shortdesc": "Boot priority for VMs",
							"type": "integer"
						}
					},
					{
						"hwaddr": {
							"defaultdesc": "randomly assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"maas.subnet.ipv4": {
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "MAAS IPv4 subnet to register the instance in",
							"type": "string"
						}
					},
					{
						"maas.subnet.ipv6": {
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "MAAS IPv6 subnet to register the instance in",
							"type": "string"
						}
					},
					{
						"mtu": {
							"defaultdesc": "kernel assigned",
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "MTU of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"defaultdesc": "kernel assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"network": {
							"longdesc": "You can specify this option instead of specifying the `nictype` directly.",
							"managed": "no",
							"shortdesc": "Managed network to link the device to",
							"type": "string"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"managed": "yes",
							"required": "if specifying the `nictype` directly",
							"shortdesc": "Name of the host device",
							"type": "string"
						}
					},
					{
						"security.mac_filtering": {
							"defaultdesc": "`false`",
							"longdesc": "Set this option to `true` to prevent the instance from spoofing another instanceâ€™s MAC address.",
							"managed": "no",
							"shortdesc": "Whether to prevent the instance from spoofing a MAC address",
							"type": "bool"
						}
					},
					{
						"vlan": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "VLAN ID to attach to",
							"type": "integer"
						}
					}
				]
			}
		},
		"device-pci": {
			"device-conf": {
				"keys": [
					{
						"address": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "PCI address of the device",
							"type": "string"
						}
					}
				]
			}
		},
		"device-proxy": {
			"device-conf": {
				"keys": [
					{
						"bind": {
							"defaultdesc": "`host`",
							"longdesc": "Possible values are `host` and `instance`.",
							"required": "no",
							"shortdesc": "Which side to bind on",
							"type": "string"
						}
					},
					{
						"connect": {
							"longdesc": "Use the following format to specify the address and port: `\u003ctype\u003e:\u003caddr\u003e:\u003cport\u003e[-\u003cport\u003e][,\u003cport\u003e]`",
							"required": "yes",
							"shortdesc": "Address and port to connect to",
							"type": "string"
						}
					},
					{
						"gid": {
							"defaultdesc": "`0`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "GID of the owner of the listening Unix socket",
							"type": "integer"
						}
					},
					{
						"listen": {
							"longdesc": "Use the following format to specify the address and port: `\u003ctype\u003e:\u003caddr\u003e:\u003cport\u003e[-\u003cport\u003e][,\u003cport\u003e]`",
							"required": "yes",
							"shortdesc": "Address and port to bind and listen",
							"type": "string"
						}
					},
					{
						"mode": {
							"defaultdesc": "`0644`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Mode for the listening Unix socket",
							"type": "integer"
						}
					},
					{
						"nat": {
							"defaultdesc": "`false`",
							"longdesc": "This option requires that the instance NIC has a static IP address.",
							"required": "no",
							"shortdesc": "Whether to optimize proxying via NAT",
							"type": "bool"
						}
					},
					{
						"proxy_protocol": {
							"defaultdesc": "`false`",
							"longdesc": "This option specifies whether to use the HAProxy PROXY protocol to transmit sender information.",
							"required": "no",
							"shortdesc": "Whether to use the HAProxy PROXY protocol",
							"type": "bool"
						}
					},
					{
						"security.gid": {
							"defaultdesc": "`0`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "What GID to drop privilege to",
							"type": "integer"
						}
					},
					{
						"security.uid": {
							"defaultdesc": "`0`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "What UID to drop privilege to",
							"type": "integer"
						}
					},
					{
						"uid": {
							"defaultdesc": "`0`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "UID of the owner of the listening Unix socket",
							"type": "integer"
						}
					}
				]
			}
		},
		"device-tpm": {
			"device-conf": {
				"keys": [
					{
						"path": {
							"longdesc": "For example: `/dev/tpm0`",
							"required": "for containers",
							"shortdesc": "Path inside the container",
							"type": "string"
						}
					},
					{
						"pathrm": {
							"longdesc": "For example: `/dev/tpmrm0`",
							"required": "for containers",
							"shortdesc": "Resource manager path inside the container",
							"type": "string"
						}
					}
				]
			}
		},
		"device-unix-block": {
			"device-conf": {
				"keys": [
					{
						"gid": {
							"defaultdesc": "`0`",
							"longdesc": "",
							"shortdesc": "GID of the device owner in the container",
							"type": "integer"
						}
					},
					{
						"major": {
							"defaultdesc": "device on host",
							"longdesc": "",
							"shortdesc": "Device major number",
							"type": "integer"
						}
					},
					{
						"minor": {
							"defaultdesc": "device on host",
							"longdesc": "",
							"shortdesc": "Device minor number",
							"type": "integer"
						}
					},
					{
						"mode": {
							"defaultdesc": "`0660`",
							"longdesc": "",
							"shortdesc": "Mode of the device in the container",
							"type": "integer"
						}
					},
					{
						"path": {
							"longdesc": "",
							"required": "either `source` or `path` must be set",
							"shortdesc": "Path inside the container",
							"type": "string"
						}
					},
					{
						"required": {
							"defaultdesc": "`true`",
							"longdesc": "See {ref}`devices-unix-block-hotplugging` for more information.",
							"shortdesc": "Whether this device is required to start the container",
							"type": "bool"
						}
					},
					{
						"source": {
							"longdesc": "",
							"required": "either `source` or `path` must be set",
							"shortdesc": "Path on the host",
							"type": "string"
						}
					},
					{
						"uid": {
							"defaultdesc": "`0`",
							"longdesc": "",
							"shortdesc": "UID of the device owner in the container",
							"type": "integer"
						}
					}
				]
			}
		},
		"device-unix-char": {
			"device-conf": {
				"keys": [
					{
						"gid": {
							"defaultdesc": "`0`",
							"longdesc": "",
							"shortdesc": "GID of the device owner in the container",
							"type": "integer"
						}
					},
					{
						"major": {
							"defaultdesc": "device on host",
							"longdesc": "",
							"shortdesc": "Device major number",
							"type": "integer"
						}
					},
					{
						"minor": {
							"defaultdesc": "device on host",
							"longdesc": "",
							"shortdesc": "Device minor number",
							"type": "integer"
						}
					},
					{
						"mode": {
							"defaultdesc": "`0660`",
							"longdesc": "",
							"shortdesc": "Mode of the device in the container",
							"type": "integer"
						}
					},
					{
						"path": {
							"longdesc": "",
							"required": "either `source` or `path` must be set",
							"shortdesc": "Path inside the container",
							"type": "string"
						}
					},
					{
						"required": {
							"defaultdesc": "`true`",
							"longdesc": "See {ref}`devices-unix-char-hotplugging` for more information.",
							"shortdesc": "Whether this device is required to start the container",
							"type": "bool"
						}
					},
					{
						"source": {
							"longdesc": "",
							"required": "either `source` or `path` must be set",
							"shortdesc": "Path on the host",
							"type": "string"
						}
					},
					{
						"uid": {
							"defaultdesc": "`0`",
							"longdesc": "",
							"shortdesc": "UID of the device owner in the container",
							"type": "integer"
						}
					}
				]
			}
		},
		"device-unix-hotplug": {
			"device-conf": {
				"keys": [
					{
						"gid": {
							"defaultdesc": "`0`",
							"longdesc": "",
							"shortdesc": "GID of the device owner in the container",
							"type": "integer"
						}
					},
					{
						"mode": {
							"defaultdesc": "`0660`",
							"longdesc": "",
							"shortdesc": "Mode of the device in the container",
							"type": "integer"
						}
					},
					{
						"ownership.inherit": {
							"defaultdesc": "`false`",
							"longdesc": "",
							"shortdesc": "Whether this device inherits ownership (GID and/or UID) from the host",
							"type": "bool"
						}
					},
					{
						"productid": {
							"longdesc": "",
							"shortdesc": "Product ID of the Unix device",
							"type": "string"
						}
					},
					{
						"required": {
							"defaultdesc": "`false`",
							"longdesc": "The default is `false`, which means that all devices can be hotplugged.",
							"shortdesc": "Whether this device is required to start the container",
							"type": "bool"
						}
					},
					{
						"subsystem": {
							"longdesc": "",
							"shortdesc": "Subsystem of the Unix device",
							"type": "string"
						}
					},
					{
						"uid": {
							"defaultdesc": "`0`",
							"longdesc": "",
							"shortdesc": "UID of the device owner in the container",
							"type": "integer"
						}
					},
					{
						"vendorid": {
							"longdesc": "",
							"shortdesc": "Vendor ID of the Unix device",
							"type": "string"
						}
					}
				]
			}
		},
		"device-unix-usb": {
			"device-conf": {
				"keys": [
					{
						"busnum": {
							"longdesc": "",
							"shortdesc": "The bus number of which the USB device is attached",
							"type": "int"
						}
					},
					{
						"devnum": {
							"longdesc": "",
							"shortdesc": "The device number of the USB device",
							"type": "int"
						}
					},
					{
						"gid": {
							"condition": "container",
							"defaultdesc": "`0`",
							"longdesc": "",
							"shortdesc": "GID of the device owner in the instance",
							"type": "integer"
						}
					},
					{
						"mode": {
							"condition": "container",
							"defaultdesc": "`0660`",
							"longdesc": "",
							"shortdesc": "Mode of the device in the instance",
							"type": "integer"
						}
					},
					{
						"productid": {
							"longdesc": "",
							"shortdesc": "Product ID of the USB device",
							"type": "string"
						}
					},
					{
						"required": {
							"defaultdesc": "`false`",
							"longdesc": "The default is `false`, which means that all devices can be hotplugged.",
							"shortdesc": "Whether this device is required to start the instance",
							"type": "bool"
						}
					},
					{
						"serial": {
							"longdesc": "",
							"shortdesc": "The serial number of the USB device",
							"type": "string"
						}
					},
					{
						"uid": {
							"condition": "container",
							"defaultdesc": "`0`",
							"longdesc": "",
							"shortdesc": "UID of the device owner in the instance",
							"type": "integer"
						}
					},
					{
						"vendorid": {
							"longdesc": "",
							"shortdesc": "Vendor ID of the USB device",
							"type": "string"
						}
					}
				]
			}
		},
		"instance": {
			"boot": {
				"keys": [
					{
						"boot.autostart": {
							"liveupdate": "no",
							"longdesc": "If set to `false`, restore the last state.",
							"shortdesc": "Whether to always start the instance when LXD starts",
							"type": "bool"
						}
					},
					{
						"boot.autostart.delay": {
							"defaultdesc": "`0`",
							"liveupdate": "no",
							"longdesc": "The number of seconds to wait after the instance started before starting the next one.",
							"shortdesc": "Delay after starting the instance",
							"type": "integer"
						}
					},
					{
						"boot.autostart.priority": {
							"defaultdesc": "`0`",
							"liveupdate": "no",
							"longdesc": "The instance with the highest value is started first.",
							"shortdesc": "What order to start the instances in",
							"type": "integer"
						}
					},
					{
						"boot.debug_edk2": {
							"longdesc": "The instance should use a debug version of the `edk2`.\nA log file can be found in `$LXD_DIR/logs/\u003cinstance_name\u003e/edk2.log`.",
							"shortdesc": "Enable debug version of the `edk2`",
							"type": "bool"
						}
					},
					{
						"boot.host_shutdown_timeout": {
							"defaultdesc": "`30`",
							"liveupdate": "yes",
							"longdesc": "Number of seconds to wait for the instance to shut down before it is force-stopped.",
							"shortdesc": "How long to wait for the instance to shut down",
							"type": "integer"
						}
					},
					{
						"boot.stop.priority": {
							"defaultdesc": "`0`",
							"liveupdate": "no",
							"longdesc": "The instance with the highest value is shut down first.",
							"shortdesc": "What order to shut down the instances in",
							"type": "integer"
						}
					}
				]
			},
			"cloud-init": {
				"keys": [
					{
						"cloud-init.network-config": {
							"condition": "If supported by image",
							"defaultdesc": "`DHCP on eth0`",
							"liveupdate": "no",
							"longdesc": "The content is used as seed value for `cloud-init`.",
							"shortdesc": "Network configuration for `cloud-init`",
							"type": "string"
						}
					},
					{
						"cloud-init.user-data": {
							"condition": "If supported by image",
							"defaultdesc": "`#cloud-config`",
							"liveupdate": "no",
							"longdesc": "The content is used as seed value for `cloud-init`.",
							"shortdesc": "User data for `cloud-init`",
							"type": "string"
						}
					},
					{
						"cloud-init.vendor-data": {
							"condition": "If supported by image",
							"defaultdesc": "`#cloud-config`",
							"liveupdate": "no",
							"longdesc": "The content is used as seed value for `cloud-init`.",
							"shortdesc": "Vendor data for `cloud-init`",
							"type": "string"
						}
					},
					{
						"user.network-config": {
							"condition": "If supported by image",
							"defaultdesc": "`DHCP on eth0`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Legacy version of `cloud-init.network-config`",
							"type": "string"
						}
					},
					{
						"user.user-data": {
							"condition": "If supported by image",
							"defaultdesc": "`#cloud-config`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Legacy version of `cloud-init.user-data`",
							"type": "string"
						}
					},
					{
						"user.vendor-data": {
							"condition": "If supported by image",
							"defaultdesc": "`#cloud-config`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Legacy version of `cloud-init.vendor-data`",
							"type": "string"
						}
					}
				]
			},
			"migration": {
				"keys": [
					{
						"migration.incremental.memory": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "yes",
							"longdesc": "Using incremental memory transfer of the instance's memory can reduce downtime.",
							"shortdesc": "Whether to use incremental memory transfer",
							"type": "bool"
						}
					},
					{
						"migration.incremental.memory.goal": {
							"condition": "container",
							"defaultdesc": "`70`",
							"liveupdate": "yes",
							"longdesc": "",
							"shortdesc": "Percentage of memory to have in sync before stopping the instance",
							"type": "integer"
						}
					},
					{
						"migration.incremental.memory.iterations": {
							"condition": "container",
							"defaultdesc": "`10`",
							"liveupdate": "yes",
							"longdesc": "",
							"shortdesc": "Maximum number of transfer operations to go through before stopping the instance",
							"type": "integer"
						}
					},
					{
						"migration.stateful": {
							"condition": "virtual machine",
							"defaultdesc": "`false` or value from profiles or `instances.migration.stateful` (if set)",
							"liveupdate": "no",
							"longdesc": "Enabling this option prevents the use of some features that are incompatible with it.",
							"shortdesc": "Whether to allow for stateful stop/start and snapshots",
							"type": "bool"
						}
					}
				]
			},
			"miscellaneous": {
				"keys": [
					{
						"agent.nic_config": {
							"condition": "virtual machine",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "For containers, the name and MTU of the default network interfaces is used for the instance devices.\nFor virtual machines, set this option to `true` to set the name and MTU of the default network interfaces to be the same as the instance devices.",
							"shortdesc": "Whether to use the name and MTU of the default network interfaces",
							"type": "bool"
						}
					},
					{
						"cluster.evacuate": {
							"defaultdesc": "`auto`",
							"liveupdate": "no",
							"longdesc": "The `cluster.evacuate` provides control over how instances are handled when a cluster member is being\nevacuated.\n\nAvailable Modes:\n  - `auto` *(default)*: The system will automatically decide the best evacuation method based on the\n     instance's type and configured devices:\n    + If any device is not suitable for migration, the instance will not be migrated (only stopped).\n    + Live migration will be used only for virtual machines with the `migration.stateful` setting\n      enabled and for which all its devices can be migrated as well.\n  - `live-migrate`: Instances are live-migrated to another node. This means the instance remains running\n     and operational during the migration process, ensuring minimal disruption.\n  - `migrate`: In this mode, instances are migrated to another node in the cluster. The migration\n     process will not be live, meaning there will be a brief downtime for the instance during the\n     migration.\n  -  `stop`: Instances are not migrated. Instead, they are stopped on the current node.\n\nSee {ref}`cluster-evacuate` for more information.",
							"shortdesc": "What to do when evacuating the instance",
							"type": "string"
						}
					},
					{
						"linux.kernel_modules": {
							"condition": "container",
							"liveupdate": "yes",
							"longdesc": "Specify the kernel modules as a comma-separated list.\n\nThe modules are loaded before the instance starts, or they can be loaded by a privileged user if {config:option}`instance-miscellaneous:linux.kernel_modules.load` is set to `ondemand`.",
							"shortdesc": "Kernel modules to load or allow loading",
							"type": "string"
						}
					},
					{
						"linux.kernel_modules.load": {
							"condition": "container",
							"defaultdesc": "`boot`",
							"liveupdate": "no",
							"longdesc": "This option specifies how to load the kernel modules that are specified in {config:option}`instance-miscellaneous:linux.kernel_modules`.\nPossible values are `boot` (load the modules when booting the container) and `ondemand` (intercept the `finit_modules()` syscall and allow a privileged user in the container's user namespace to load the modules).",
							"shortdesc": "How to load kernel modules",
							"type": "string"
						}
					},
					{
						"linux.sysctl.*": {
							"condition": "container",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Override for the corresponding `sysctl` setting in the container",
							"type": "string"
						}
					},
					{
						"user.*": {
							"liveupdate": "no",
							"longdesc": "User keys can be used in search.",
							"shortdesc": "Free-form user key/value storage",
							"type": "string"
						}
					}
				]
			},
			"nvidia": {
				"keys": [
					{
						"nvidia.driver.capabilities": {
							"condition": "container",
							"defaultdesc": "`compute,utility`",
							"liveupdate": "no",
							"longdesc": "The specified driver capabilities are used to set `libnvidia-container NVIDIA_DRIVER_CAPABILITIES`.",
							"shortdesc": "What driver capabilities the instance needs",
							"type": "string"
						}
					},
					{
						"nvidia.require.cuda": {
							"condition": "container",
							"liveupdate": "no",
							"longdesc": "The specified version expression is used to set `libnvidia-container NVIDIA_REQUIRE_CUDA`.",
							"shortdesc": "Required CUDA version",
							"type": "string"
						}
					},
					{
						"nvidia.require.driver": {
							"condition": "container",
							"liveupdate": "no",
							"longdesc": "The specified version expression is used to set `libnvidia-container NVIDIA_REQUIRE_DRIVER`.",
							"shortdesc": "Required driver version",
							"type": "string"
						}
					},
					{
						"nvidia.runtime": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether to pass the host NVIDIA and CUDA runtime libraries into the instance",
							"type": "bool"
						}
					}
				]
			},
			"raw": {
				"keys": [
					{
						"raw.apparmor": {
							"liveupdate": "yes",
							"longdesc": "The specified entries are appended to the generated profile.",
							"shortdesc": "AppArmor profile entries",
							"type": "blob"
						}
					},
					{
						"raw.idmap": {
							"condition": "unprivileged container",
							"liveupdate": "no",
							"longdesc": "For example: `both 1000 1000`",
							"shortdesc": "Raw idmap configuration",
							"type": "blob"
						}
					},
					{
						"raw.lxc": {
							"condition": "container",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Raw LXC configuration to be appended to the generated one",
							"type": "blob"
						}
					},
					{
						"raw.qemu": {
							"condition": "virtual machine",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Raw QEMU configuration to be appended to the generated command line",
							"type": "blob"
						}
					},
					{
						"raw.qemu.conf": {
							"condition": "virtual machine",
							"liveupdate": "no",
							"longdesc": "See {ref}`instance-options-qemu` for more information.",
							"shortdesc": "Addition/override to the generated `qemu.conf` file",
							"type": "blob"
						}
					},
					{
						"raw.seccomp": {
							"condition": "container",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Raw Seccomp configuration",
							"type": "blob"
						}
					}
				]
			},
			"resource-limits": {
				"keys": [
					{
						"limits.cpu": {
							"defaultdesc": "1 (VMs)",
							"liveupdate": "yes",
							"longdesc": "A number or a specific range of CPUs to expose to the instance.\n\nSee {ref}`instance-options-limits-cpu` for more information.",
							"shortdesc": "Which CPUs to expose to the instance",
							"type": "string"
						}
					},
					{
						"limits.cpu.allowance": {
							"condition": "container",
							"defaultdesc": "100%",
							"liveupdate": "yes",
							"longdesc": "To control how much of the CPU can be used, specify either a percentage (`50%`) for a soft limit\nor a chunk of time (`25ms/100ms`) for a hard limit.\n\nSee {ref}`instance-options-limits-cpu-container` for more information.",
							"shortdesc": "How much of the CPU can be used",
							"type": "string"
						}
					},
					{
						"limits.cpu.nodes": {
							"liveupdate": "yes",
							"longdesc": "A comma-separated list of NUMA node IDs or ranges to place the instance CPUs on.\n\nSee {ref}`instance-options-limits-cpu-container` for more information.",
							"shortdesc": "Which NUMA nodes to place the instance CPUs on",
							"type": "string"
						}
					},
					{
						"limits.cpu.pin_strategy": {
							"condition": "virtual machine",
							"defaultdesc": "`none`",
							"liveupdate": "no",
							"longdesc": "Specify the strategy for VM CPU auto pinning.\nPossible values: `none` (disables CPU auto pinning) and `auto` (enables CPU auto pinning).\n\nSee {ref}`instance-options-limits-cpu-vm` for more information.",
							"shortdesc": "VM CPU auto pinning strategy",
							"type": "string"
						}
					},
					{
						"limits.cpu.priority": {
							"condition": "container",
							"defaultdesc": "`10` (maximum)",
							"liveupdate": "yes",
							"longdesc": "When overcommitting resources, specify the CPU scheduling priority compared to other instances that share the same CPUs.\nSpecify an integer between 0 and 10.\n\nSee {ref}`instance-options-limits-cpu-container` for more information.",
							"shortdesc": "CPU scheduling priority compared to other instances",
							"type": "integer"
						}
					},
					{
						"limits.disk.priority": {
							"defaultdesc": "`5` (medium)",
							"liveupdate": "yes",
							"longdesc": "Controls how much priority to give to the instance's I/O requests when under load.\n\nSpecify an integer between 0 and 10.",
							"shortdesc": "Priority of the instance's I/O requests",
							"type": "integer"
						}
					},
					{
						"limits.hugepages.1GB": {
							"condition": "container",
							"liveupdate": "yes",
							"longdesc": "Fixed value (in bytes) to limit the number of 1 GB huge pages.\nVarious suffixes are supported (see {ref}`instances-limit-units`).\n\nSee {ref}`instance-options-limits-hugepages` for more information.",
							"shortdesc": "Limit for the number of 1 GB huge pages",
							"type": "string"
						}
					},
					{
						"limits.hugepages.1MB": {
							"condition": "container",
							"liveupdate": "yes",
							"longdesc": "Fixed value (in bytes) to limit the number of 1 MB huge pages.\nVarious suffixes are supported (see {ref}`instances-limit-units`).\n\nSee {ref}`instance-options-limits-hugepages` for more information.",
							"shortdesc": "Limit for the number of 1 MB huge pages",
							"type": "string"
						}
					},
					{
						"limits.hugepages.2MB": {
							"condition": "container",
							"liveupdate": "yes",
							"longdesc": "Fixed value (in bytes) to limit the number of 2 MB huge pages.\nVarious suffixes are supported (see {ref}`instances-limit-units`).\n\nSee {ref}`instance-options-limits-hugepages` for more information.",
							"shortdesc": "Limit for the number of 2 MB huge pages",
							"type": "string"
						}
					},
					{
						"limits.hugepages.64KB": {
							"condition": "container",
							"liveupdate": "yes",
							"longdesc": "Fixed value (in bytes) to limit the number of 64 KB huge pages.\nVarious suffixes are supported (see {ref}`instances-limit-units`).\n\nSee {ref}`instance-options-limits-hugepages` for more information.",
							"shortdesc": "Limit for the number of 64 KB huge pages",
							"type": "string"
						}
					},
					{
						"limits.memory": {
							"defaultdesc": "`1GiB` (VMs)",
							"liveupdate": "yes",
							"longdesc": "Percentage of the host's memory or a fixed value in bytes.\nVarious suffixes are supported.\n\nSee {ref}`instances-limit-units` for details.",
							"shortdesc": "Usage limit for the host's memory",
							"type": "string"
						}
					},
					{
						"limits.memory.enforce": {
							"condition": "container",
							"defaultdesc": "`hard`",
							"liveupdate": "yes",
							"longdesc": "If the instance's memory limit is `hard`, the instance cannot exceed its limit.\nIf it is `soft`, the instance can exceed its memory limit when extra host memory is available.",
							"shortdesc": "Whether the memory limit is `hard` or `soft`",
							"type": "string"
						}
					},
					{
						"limits.memory.hugepages": {
							"condition": "virtual machine",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "If this option is set to `false`, regular system memory is used.",
							"shortdesc": "Whether to back the instance using huge pages",
							"type": "bool"
						}
					},
					{
						"limits.memory.swap": {
							"condition": "container",
							"defaultdesc": "`true`",
							"liveupdate": "yes",
							"longdesc": "",
							"shortdesc": "Whether to encourage/discourage swapping less used pages for this instance",
							"type": "bool"
						}
					},
					{
						"limits.memory.swap.priority": {
							"condition": "container",
							"defaultdesc": "`10` (maximum)",
							"liveupdate": "yes",
							"longdesc": "Specify an integer between 0 and 10.\nThe higher the value, the less likely the instance is to be swapped to disk.",
							"shortdesc": "Prevents the instance from being swapped to disk",
							"type": "integer"
						}
					},
					{
						"limits.processes": {
							"condition": "container",
							"defaultdesc": "empty",
							"liveupdate": "yes",
							"longdesc": "If left empty, no limit is set.",
							"shortdesc": "Maximum number of processes that can run in the instance",
							"type": "integer"
						}
					}
				]
			},
			"security": {
				"keys": [
					{
						"security.agent.metrics": {
							"condition": "virtual machine",
							"defaultdesc": "`true`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether the `lxd-agent` is queried for state information and metrics",
							"type": "bool"
						}
					},
					{
						"security.csm": {
							"condition": "virtual machine",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "When enabling this option, set {config:option}`instance-security:security.secureboot` to `false`.",
							"shortdesc": "Whether to use a firmware that supports UEFI-incompatible operating systems",
							"type": "bool"
						}
					},
					{
						"security.devlxd": {
							"defaultdesc": "`true`",
							"liveupdate": "no",
							"longdesc": "See {ref}`dev-lxd` for more information.",
							"shortdesc": "Whether `/dev/lxd` is present in the instance",
							"type": "bool"
						}
					},
					{
						"security.devlxd.images": {
							"defaultdesc": "`false`",
							"liveupdate": "yes",
							"longdesc": "",
							"shortdesc": "Controls the availability of the `/1.0/images` API over `devlxd`",
							"type": "bool"
						}
					},
					{
						"security.idmap.base": {
							"condition": "unprivileged container",
							"liveupdate": "no",
							"longdesc": "Setting this option overrides auto-detection.",
							"shortdesc": "The base host ID to use for the allocation",
							"type": "integer"
						}
					},
					{
						"security.idmap.isolated": {
							"condition": "unprivileged container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "If specified, the idmap used for this instance is unique among instances that have this option set.",
							"shortdesc": "Whether to use a unique idmap for this instance",
							"type": "bool"
						}
					},
					{
						"security.idmap.size": {
							"condition": "unprivileged container",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "The size of the idmap to use",
							"type": "integer"
						}
					},
					{
						"security.nesting": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "yes",
							"longdesc": "",
							"shortdesc": "Whether to support running LXD (nested) inside the instance",
							"type": "bool"
						}
					},
					{
						"security.privileged": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "See {ref}`container-security` for more information.",
							"shortdesc": "Whether to run the instance in privileged mode",
							"type": "bool"
						}
					},
					{
						"security.protection.delete": {
							"defaultdesc": "`false`",
							"liveupdate": "container",
							"longdesc": "",
							"shortdesc": "Whether to prevent the instance from being deleted",
							"type": "bool"
						}
					},
					{
						"security.protection.shift": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "yes",
							"longdesc": "Set this option to `true` to prevent the instance's file system from being UID/GID shifted on startup.",
							"shortdesc": "Whether to protect the file system from being UID/GID shifted",
							"type": "bool"
						}
					},
					{
						"security.protection.start": {
							"defaultdesc": "`false`",
							"liveupdate": "container",
							"longdesc": "",
							"shortdesc": "Whether to prevent the instance from being started",
							"type": "bool"
						}
					},
					{
						"security.secureboot": {
							"condition": "virtual machine",
							"defaultdesc": "`true`",
							"liveupdate": "no",
							"longdesc": "When disabling this option, consider enabling {config:option}`instance-security:security.csm`.",
							"shortdesc": "Whether UEFI secure boot is enabled with the default Microsoft keys",
							"type": "bool"
						}
					},
					{
						"security.sev": {
							"condition": "virtual machine",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether AMD SEV (Secure Encrypted Virtualization) is enabled for this VM",
							"type": "bool"
						}
					},
					{
						"security.sev.policy.es": {
							"condition": "virtual machine",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether AMD SEV-ES (SEV Encrypted State) is enabled for this VM",
							"type": "bool"
						}
					},
					{
						"security.sev.session.data": {
							"condition": "virtual machine",
							"defaultdesc": "`true`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "The guest owner's `base64`-encoded session blob",
							"type": "string"
						}
					},
					{
						"security.sev.session.dh": {
							"condition": "virtual machine",
							"defaultdesc": "`true`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "The guest owner's `base64`-encoded Diffie-Hellman key",
							"type": "string"
						}
					},
					{
						"security.syscalls.allow": {
							"condition": "container",
							"liveupdate": "no",
							"longdesc": "A `\\n`-separated list of syscalls to allow.\nThis list must be mutually exclusive with `security.syscalls.deny*`.",
							"shortdesc": "List of syscalls to allow",
							"type": "string"
						}
					},
					{
						"security.syscalls.deny": {
							"condition": "container",
							"liveupdate": "no",
							"longdesc": "A `\\n`-separated list of syscalls to deny.\nThis list must be mutually exclusive with `security.syscalls.allow`.",
							"shortdesc": "List of syscalls to deny",
							"type": "string"
						}
					},
					{
						"security.syscalls.deny_compat": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "On `x86_64`, this option controls whether to block `compat_*` syscalls.\nOn other architectures, the option is ignored.",
							"shortdesc": "Whether to block `compat_*` syscalls (`x86_64` only)",
							"type": "bool"
						}
					},
					{
						"security.syscalls.deny_default": {
							"condition": "container",
							"defaultdesc": "`true`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether to enable the default syscall deny",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.bpf": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether to handle the `bpf()` system call",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.bpf.devices": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "This option controls whether to allow BPF programs for the devices cgroup in the unified hierarchy to be loaded.",
							"shortdesc": "Whether to allow BPF programs",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.mknod": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "These system calls allow creation of a limited subset of char/block devices.",
							"shortdesc": "Whether to handle the `mknod` and `mknodat` system calls",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.mount": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether to handle the `mount` system call",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.mount.allowed": {
							"condition": "container",
							"liveupdate": "yes",
							"longdesc": "Specify a comma-separated list of file systems that are safe to mount for processes inside the instance.",
							"shortdesc": "File systems that can be mounted",
							"type": "string"
						}
					},
					{
						"security.syscalls.intercept.mount.fuse": {
							"condition": "container",
							"liveupdate": "yes",
							"longdesc": "Specify the mounts of a given file system that should be redirected to their FUSE implementation (for example, `ext4=fuse2fs`).",
							"shortdesc": "File system that should be redirected to FUSE implementation",
							"type": "string"
						}
					},
					{
						"security.syscalls.intercept.mount.shift": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "yes",
							"longdesc": "",
							"shortdesc": "Whether to use idmapped mounts for syscall interception",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.sched_setscheduler": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "This system call allows increasing process priority.",
							"shortdesc": "Whether to handle the `sched_setscheduler` system call",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.setxattr": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "This system call allows setting a limited subset of restricted extended attributes.",
							"shortdesc": "Whether to handle the `setxattr` system call",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.sysinfo": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "This system call can be used to get cgroup-based resource usage information.",
							"shortdesc": "Whether to handle the `sysinfo` system call",
							"type": "bool"
						}
					}
				]
			},
			"snapshots": {
				"keys": [
					{
						"snapshots.expiry": {
							"liveupdate": "no",
							"longdesc": "Specify an expression like `1M 2H 3d 4w 5m 6y`.",
							"shortdesc": "When snapshots are to be deleted",
							"type": "string"
						}
					},
					{
						"snapshots.pattern": {
							"defaultdesc": "`snap%d`",
							"liveupdate": "no",
							"longdesc": "Specify a Pongo2 template string that represents the snapshot name.\nThis template is used for scheduled snapshots and for unnamed snapshots.\n\nSee {ref}`instance-options-snapshots-names` for more information.",
							"shortdesc": "Template for the snapshot name",
							"type": "string"
						}
					},
					{
						"snapshots.schedule": {
							"defaultdesc": "empty",
							"liveupdate": "no",
							"longdesc": "Specify either a cron expression (`\u003cminute\u003e \u003chour\u003e \u003cdom\u003e \u003cmonth\u003e \u003cdow\u003e`), a comma-separated list of schedule aliases (`@hourly`, `@daily`, `@midnight`, `@weekly`, `@monthly`, `@annually`, `@yearly`), or leave empty to disable automatic snapshots.\n",
							"shortdesc": "Schedule for automatic instance snapshots",
							"type": "string"
						}
					},
					{
						"snapshots.schedule.stopped": {
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether to automatically snapshot stopped instances",
							"type": "bool"
						}
					}
				]
			},
			"volatile": {
				"keys": [
					{
						"volatile.\u003cname\u003e.apply_quota": {
							"longdesc": "The disk quota is applied the next time the instance starts.",
							"shortdesc": "Disk quota",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.ceph_rbd": {
							"longdesc": "",
							"shortdesc": "RBD device path for Ceph disk devices",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.host_name": {
							"longdesc": "",
							"shortdesc": "Network device name on the host",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.hwaddr": {
							"longdesc": "The network device MAC address is used when no `hwaddr` property is set on the device itself.",
							"shortdesc": "Network device MAC address",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.created": {
							"longdesc": "Possible values are `true` or `false`.",
							"shortdesc": "Whether the network device physical device was created",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.hwaddr": {
							"longdesc": "The original MAC that was used when moving a physical device into an instance.",
							"shortdesc": "Network device original MAC",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.mtu": {
							"longdesc": "The original MTU that was used when moving a physical device into an instance.",
							"shortdesc": "Network device original MTU",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.vdpa.name": {
							"longdesc": "The VDPA device name used when moving a VDPA device file descriptor into an instance.",
							"shortdesc": "VDPA device name",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.vf.hwaddr": {
							"longdesc": "The original MAC used when moving a VF into an instance.",
							"shortdesc": "SR-IOV virtual function original MAC",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.vf.id": {
							"longdesc": "The ID used when moving a VF into an instance.",
							"shortdesc": "SR-IOV virtual function ID",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.vf.spoofcheck": {
							"longdesc": "The original spoof check setting used when moving a VF into an instance.",
							"shortdesc": "SR-IOV virtual function original spoof check setting",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.vf.vlan": {
							"longdesc": "The original VLAN used when moving a VF into an instance.",
							"shortdesc": "SR-IOV virtual function original VLAN",
							"type": "string"
						}
					},
					{
						"volatile.apply_nvram": {
							"longdesc": "",
							"shortdesc": "Whether to regenerate VM NVRAM the next time the instance starts",
							"type": "bool"
						}
					},
					{
						"volatile.apply_template": {
							"longdesc": "The template with the given name is triggered upon next startup.",
							"shortdesc": "Template hook",
							"type": "string"
						}
					},
					{
						"volatile.base_image": {
							"longdesc": "The hash of the image that the instance was created from (empty if the instance was not created from an image).",
							"shortdesc": "Hash of the base image",
							"type": "string"
						}
					},
					{
						"volatile.cloud-init.instance-id": {
							"longdesc": "",
							"shortdesc": "`instance-id` (UUID) exposed to `cloud-init`",
							"type": "string"
						}
					},
					{
						"volatile.evacuate.origin": {
							"longdesc": "The cluster member that the instance lived on before evacuation.",
							"shortdesc": "The origin of the evacuated instance",
							"type": "string"
						}
					},
					{
						"volatile.idmap.base": {
							"longdesc": "",
							"shortdesc": "The first ID in the instance's primary idmap range",
							"type": "integer"
						}
					},
					{
						"volatile.idmap.current": {
							"longdesc": "",
							"shortdesc": "The idmap currently in use by the instance",
							"type": "string"
						}
					},
					{
						"volatile.idmap.next": {
							"longdesc": "",
							"shortdesc": "The idmap to use the next time the instance starts",
							"type": "string"
						}
					},
					{
						"volatile.last_state.idmap": {
							"longdesc": "",
							"shortdesc": "Serialized instance UID/GID map",
							"type": "string"
						}
					},
					{
						"volatile.last_state.power": {
							"longdesc": "",
							"shortdesc": "Instance state as of last host shutdown",
							"type": "string"
						}
					},
					{
						"volatile.uuid": {
							"longdesc": "The instance UUID is globally unique across all servers and projects.",
							"shortdesc": "Instance UUID",
							"type": "string"
						}
					},
					{
						"volatile.uuid.generation": {
							"longdesc": "The instance generation UUID changes whenever the instance's place in time moves backwards.\nIt is globally unique across all servers and projects.",
							"shortdesc": "Instance generation UUID",
							"type": "string"
						}
					},
					{
						"volatile.vsock_id": {
							"longdesc": "",
							"shortdesc": "Instance `vsock ID` used as of last start",
							"type": "string"
						}
					}
				]
			}
		},
		"instance-property": {
			"instance-conf": {
				"keys": [
					{
						"architecture": {
							"longdesc": "",
							"readonly": "no",
							"shortdesc": "Instance architecture",
							"type": "string"
						}
					},
					{
						"name": {
							"longdesc": "See {ref}`instance-name-requirements`.",
							"readonly": "yes",
							"shortdesc": "Instance name",
							"type": "string"
						}
					}
				]
			}
		},
		"network-acl": {
			"acl-properties": {
				"keys": [
					{
						"config": {
							"longdesc": "The only supported keys are `user.*` custom keys.",
							"required": "no",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string set"
						}
					},
					{
						"description": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Description of the network ACL",
							"type": "string"
						}
					},
					{
						"egress": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Egress traffic rules",
							"type": "rule list"
						}
					},
					{
						"ingress": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Ingress traffic rules",
							"type": "rule list"
						}
					},
					{
						"name": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "Unique name of the network ACL in the project",
							"type": "string"
						}
					}
				]
			},
			"rule-properties": {
				"keys": [
					{
						"action": {
							"longdesc": "Possible values are `allow`, `reject`, and `drop`.",
							"required": "yes",
							"shortdesc": "Action to take for matching traffic",
							"type": "string"
						}
					},
					{
						"description": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Description of the rule",
							"type": "string"
						}
					},
					{
						"destination": {
							"longdesc": "Destinations can be specified as CIDR or IP ranges, destination subject name selectors (for egress rules), or be left empty for any.",
							"required": "no",
							"shortdesc": "Comma-separated list of destinations",
							"type": "string"
						}
					},
					{
						"destination_port": {
							"longdesc": "This option is valid only if the protocol is `udp` or `tcp`.\nSpecify a comma-separated list of ports or port ranges (start-end inclusive), or leave the value empty for any.",
							"required": "no",
							"shortdesc": "Destination ports or port ranges",
							"type": "string"
						}
					},
					{
						"icmp_code": {
							"longdesc": "This option is valid only if the protocol is `icmp4` or `icmp6`.\nSpecify the ICMP code number, or leave the value empty for any.",
							"required": "no",
							"shortdesc": "ICMP message code",
							"type": "string"
						}
					},
					{
						"icmp_type": {
							"longdesc": "This option is valid only if the protocol is `icmp4` or `icmp6`.\nSpecify the ICMP type number, or leave the value empty for any.",
							"required": "no",
							"shortdesc": "Type of ICMP message",
							"type": "string"
						}
					},
					{
						"protocol": {
							"longdesc": "Possible values are `icmp4`, `icmp6`, `tcp`, and `udp`.\nLeave the value empty to match any protocol.",
							"required": "no",
							"shortdesc": "Protocol to match",
							"type": "string"
						}
					},
					{
						"source": {
							"longdesc": "Sources can be specified as CIDR or IP ranges, source subject name selectors (for ingress rules), or be left empty for any.",
							"required": "no",
							"shortdesc": "Comma-separated list of sources",
							"type": "string"
						}
					},
					{
						"source_port": {
							"longdesc": "This option is valid only if the protocol is `udp` or `tcp`.\nSpecify a comma-separated list of ports or port ranges (start-end inclusive), or leave the value empty for any.",
							"required": "no",
							"shortdesc": "Source ports or port ranges",
							"type": "string"
						}
					},
					{
						"state": {
							"defaultdesc": "`enabled`",
							"longdesc": "Possible values are `enabled`, `disabled`, and `logged`.",
							"required": "yes",
							"shortdesc": "State of the rule",
							"type": "string"
						}
					}
				]
			}
		},
		"network-bridge": {
			"network-conf": {
				"keys": [
					{
						"bgp.ipv4.nexthop": {
							"condition": "BGP server",
							"defaultdesc": "local address",
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Override the IPv4 next-hop for advertised prefixes",
							"type": "string"
						}
					},
					{
						"bgp.ipv6.nexthop": {
							"condition": "BGP server",
							"defaultdesc": "local address",
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Override the IPv6 next-hop for advertised prefixes",
							"type": "string"
						}
					},
					{
						"bgp.peers.NAME.address": {
							"condition": "BGP server",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Peer address (IPv4 or IPv6)",
							"type": "string"
						}
					},
					{
						"bgp.peers.NAME.asn": {
							"condition": "BGP server",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Peer AS number",
							"type": "integer"
						}
					},
					{
						"bgp.peers.NAME.holdtime": {
							"condition": "BGP server",
							"defaultdesc": "`180`",
							"longdesc": "Specify the hold time in seconds.",
							"required": "no",
							"scope": "global",
							"shortdesc": "Peer session hold time",
							"type": "integer"
						}
					},
					{
						"bgp.peers.NAME.password": {
							"condition": "BGP server",
							"defaultdesc": "(no password)",
							"longdesc": "",
							"required": "no",
							"scope": "global",
							"shortdesc": "Peer session password",
							"type": "string"
						}
					},
					{
						"bridge.driver": {
							"defaultdesc": "`native`",
							"longdesc": "Possible values are `native` and `openvswitch`.",
							"scope": "global",
							"shortdesc": "Bridge driver",
							"type": "string"
						}
					},
					{
						"bridge.external_interfaces": {
							"longdesc": "Specify a comma-separated list of unconfigured network interfaces to include in the bridge.",
							"scope": "local",
							"shortdesc": "Unconfigured network interfaces to include in the bridge",
							"type": "string"
						}
					},
					{
						"bridge.hwaddr": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "MAC address for the bridge",
							"type": "string"
						}
					},
					{
						"bridge.mode": {
							"defaultdesc": "`standard`",
							"longdesc": "Possible values are `standard` and `fan`.",
							"scope": "global",
							"shortdesc": "Bridge operation mode",
							"type": "string"
						}
					},
					{
						"bridge.mtu": {
							"defaultdesc": "`1500` if `bridge.mode=standard`, `1480` if `bridge.mode=fan` and `fan.type=ipip`, or `1450` if `bridge.mode=fan` and `fan.type=vxlan`",
							"longdesc": "The default value varies depending on whether the bridge uses a tunnel or a fan setup.",
							"scope": "global",
							"shortdesc": "Bridge MTU",
							"type": "integer"
						}
					},
					{
						"dns.domain": {
							"defaultdesc": "`lxd`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Domain to advertise to DHCP clients and use for DNS resolution",
							"type": "string"
						}
					},
					{
						"dns.mode": {
							"defaultdesc": "`managed`",
							"longdesc": "Possible values are `none` for no DNS record, `managed` for LXD-generated static records, and `dynamic` for client-generated records.",
							"scope": "global",
							"shortdesc": "DNS registration mode",
							"type": "string"
						}
					},
					{
						"dns.search": {
							"defaultdesc": "`dns.domain` value",
							"longdesc": "Specify a comma-separated list of domains.",
							"scope": "global",
							"shortdesc": "Full domain search list",
							"type": "string"
						}
					},
					{
						"dns.zone.forward": {
							"longdesc": "Specify a comma-separated list of DNS zone names.",
							"scope": "global",
							"shortdesc": "DNS zone names for forward DNS records",
							"type": "string"
						}
					},
					{
						"dns.zone.reverse.ipv4": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "DNS zone name for IPv4 reverse DNS records",
							"type": "string"
						}
					},
					{
						"dns.zone.reverse.ipv6": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "DNS zone name for IPv6 reverse DNS records",
							"type": "string"
						}
					},
					{
						"fan.overlay_subnet": {
							"condition": "fan mode",
							"defaultdesc": "`240.0.0.0/8`",
							"longdesc": "Use CIDR notation.",
							"scope": "global",
							"shortdesc": "Subnet to use as the overlay for the FAN",
							"type": "string"
						}
					},
					{
						"fan.type": {
							"condition": "fan mode",
							"defaultdesc": "`vxlan`",
							"longdesc": "Possible values are `vxlan` and `ipip`.",
							"scope": "global",
							"shortdesc": "Tunneling type for the FAN",
							"type": "string"
						}
					},
					{
						"fan.underlay_subnet": {
							"condition": "fan mode",
							"defaultdesc": "initial value on creation: `auto`",
							"longdesc": "Use CIDR notation.\n\nYou can set the option to `auto` to use the default gateway subnet.",
							"scope": "global",
							"shortdesc": "Subnet to use as the underlay for the FAN",
							"type": "string"
						}
					},
					{
						"ipv4.address": {
							"condition": "standard mode",
							"defaultdesc": "initial value on creation: `auto`",
							"longdesc": "Use CIDR notation.\n\nYou can set the option to `none` to turn off IPv4, or to `auto` to generate a new random unused subnet.",
							"scope": "global",
							"shortdesc": "IPv4 address for the bridge",
							"type": "string"
						}
					},
					{
						"ipv4.dhcp": {
							"condition": "IPv4 address",
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to allocate IPv4 addresses using DHCP",
							"type": "bool"
						}
					},
					{
						"ipv4.dhcp.expiry": {
							"condition": "IPv4 DHCP",
							"defaultdesc": "`1h`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "When to expire DHCP leases",
							"type": "string"
						}
					},
					{
						"ipv4.dhcp.gateway": {
							"condition": "IPv4 DHCP",
							"defaultdesc": "IPv4 address",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Address of the gateway for the IPv4 subnet",
							"type": "string"
						}
					},
					{
						"ipv4.dhcp.ranges": {
							"condition": "IPv4 DHCP",
							"defaultdesc": "all addresses",
							"longdesc": "Specify a comma-separated list of IPv4 ranges in FIRST-LAST format.",
							"scope": "global",
							"shortdesc": "IPv4 ranges to use for DHCP",
							"type": "string"
						}
					},
					{
						"ipv4.firewall": {
							"condition": "IPv4 address",
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to generate filtering firewall rules for this network",
							"type": "bool"
						}
					},
					{
						"ipv4.nat": {
							"condition": "IPv4 address",
							"defaultdesc": "`false` (initial value on creation if `ipv4.address` is set to `auto`: `true`)",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to use NAT for IPv4",
							"type": "bool"
						}
					},
					{
						"ipv4.nat.address": {
							"condition": "IPv4 address",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Source address used for outbound traffic from the bridge",
							"type": "string"
						}
					},
					{
						"ipv4.nat.order": {
							"condition": "IPv4 address",
							"defaultdesc": "`before`",
							"longdesc": "Set this option to `before` to add the NAT rules before any pre-existing rules, or to `after` to add them after the pre-existing rules.",
							"scope": "global",
							"shortdesc": "Where to add the required NAT rules",
							"type": "string"
						}
					},
					{
						"ipv4.ovn.ranges": {
							"longdesc": "Specify a comma-separated list of IPv4 ranges in FIRST-LAST format.",
							"scope": "global",
							"shortdesc": "IPv4 ranges to use for child OVN network routers",
							"type": "string"
						}
					},
					{
						"ipv4.routes": {
							"condition": "IPv4 address",
							"longdesc": "Specify a comma-separated list of IPv4 CIDR subnets.",
							"scope": "global",
							"shortdesc": "Additional IPv4 CIDR subnets to route to the bridge",
							"type": "string"
						}
					},
					{
						"ipv4.routing": {
							"condition": "IPv4 address",
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to route IPv4 traffic in and out of the bridge",
							"type": "bool"
						}
					},
					{
						"ipv6.address": {
							"condition": "standard mode",
							"defaultdesc": "initial value on creation: `auto`",
							"longdesc": "Use CIDR notation.\n\nYou can set the option to `none` to turn off IPv6, or to `auto` to generate a new random unused subnet.",
							"scope": "global",
							"shortdesc": "IPv6 address for the bridge",
							"type": "string"
						}
					},
					{
						"ipv6.dhcp": {
							"condition": "IPv6 address",
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to provide additional network configuration over DHCP",
							"type": "bool"
						}
					},
					{
						"ipv6.dhcp.expiry": {
							"condition": "IPv6 DHCP",
							"defaultdesc": "`1h`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "When to expire DHCP leases",
							"type": "string"
						}
					},
					{
						"ipv6.dhcp.ranges": {
							"condition": "IPv6 stateful DHCP",
							"defaultdesc": "all addresses",
							"longdesc": "Specify a comma-separated list of IPv6 ranges in FIRST-LAST format.",
							"scope": "global",
							"shortdesc": "IPv6 ranges to use for DHCP",
							"type": "string"
						}
					},
					{
						"ipv6.dhcp.stateful": {
							"condition": "IPv6 DHCP",
							"defaultdesc": "`false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to allocate IPv6 addresses using DHCP",
							"type": "bool"
						}
					},
					{
						"ipv6.firewall": {
							"condition": "IPv6 DHCP",
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to generate filtering firewall rules for this network",
							"type": "bool"
						}
					},
					{
						"ipv6.nat": {
							"condition": "IPv6 address",
							"defaultdesc": "`false` (initial value on creation if `ipv6.address` is set to `auto`: `true`)",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to use NAT for IPv6",
							"type": "bool"
						}
					},
					{
						"ipv6.nat.address": {
							"condition": "IPv6 address",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Source address used for outbound traffic from the bridge",
							"type": "string"
						}
					},
					{
						"ipv6.nat.order": {
							"condition": "IPv6 address",
							"defaultdesc": "`before`",
							"longdesc": "Set this option to `before` to add the NAT rules before any pre-existing rules, or to `after` to add them after the pre-existing rules.",
							"scope": "global",
							"shortdesc": "Where to add the required NAT rules",
							"type": "string"
						}
					},
					{
						"ipv6.ovn.ranges": {
							"longdesc": "Specify a comma-separated list of IPv6 ranges in FIRST-LAST format.",
							"scope": "global",
							"shortdesc": "IPv6 ranges to use for child OVN network routers",
							"type": "string"
						}
					},
					{
						"ipv6.routes": {
							"condition": "IPv6 address",
							"longdesc": "Specify a comma-separated list of IPv6 CIDR subnets.",
							"scope": "global",
							"shortdesc": "Additional IPv6 CIDR subnets to route to the bridge",
							"type": "string"
						}
					},
					{
						"ipv6.routing": {
							"condition": "IPv6 address",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to route IPv6 traffic in and out of the bridge",
							"type": "bool"
						}
					},
					{
						"maas.subnet.ipv4": {
							"condition": "IPv4 address; using the `network` property on the NIC",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "MAAS IPv4 subnet to register instances in",
							"type": "string"
						}
					},
					{
						"maas.subnet.ipv6": {
							"condition": "IPv6 address; using the `network` property on the NIC",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "MAAS IPv6 subnet to register instances in",
							"type": "string"
						}
					},
					{
						"raw.dnsmasq": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Additional `dnsmasq` configuration to append to the configuration file",
							"type": "string"
						}
					},
					{
						"security.acls": {
							"longdesc": "Specify a comma-separated list of network ACLs.\n\nAlso see {ref}`network-acls-bridge-limitations`.",
							"scope": "global",
							"shortdesc": "Network ACLs to apply to NICs connected to this network",
							"type": "string"
						}
					},
					{
						"security.acls.default.egress.action": {
							"condition": "`security.acls`",
							"longdesc": "The specified action is used for all egress traffic that doesnâ€™t match any ACL rule.",
							"scope": "global",
							"shortdesc": "Default action to use for egress traffic",
							"type": "string"
						}
					},
					{
						"security.acls.default.egress.logged": {
							"condition": "`security.acls`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to log egress traffic that doesnâ€™t match any ACL rule",
							"type": "bool"
						}
					},
					{
						"security.acls.default.ingress.action": {
							"condition": "`security.acls`",
							"longdesc": "The specified action is used for all ingress traffic that doesnâ€™t match any ACL rule.",
							"scope": "global",
							"shortdesc": "Default action to use for ingress traffic",
							"type": "string"
						}
					},
					{
						"security.acls.default.ingress.logged": {
							"condition": "`security.acls`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to log ingress traffic that doesnâ€™t match any ACL rule",
							"type": "bool"
						}
					},
					{
						"tunnel.NAME.group": {
							"condition": "`vxlan`",
							"longdesc": "This address is used if {config:option}`network-bridge-network-conf:tunnel.NAME.local` and {config:option}`network-bridge-network-conf:tunnel.NAME.remote` arenâ€™t set.",
							"shortdesc": "Multicast address for `vxlan`",
							"type": "string"
						}
					},
					{
						"tunnel.NAME.id": {
							"condition": "`vxlan`",
							"longdesc": "",
							"shortdesc": "Specific tunnel ID to use for the `vxlan` tunnel",
							"type": "integer"
						}
					},
					{
						"tunnel.NAME.interface": {
							"condition": "`vxlan`",
							"longdesc": "",
							"shortdesc": "Specific host interface to use for the tunnel",
							"type": "string"
						}
					},
					{
						"tunnel.NAME.local": {
							"condition": "`gre` or `vxlan`",
							"longdesc": "",
							"required": "not required for multicast `vxlan`",
							"shortdesc": "Local address for the tunnel",
							"type": "string"
						}
					},
					{
						"tunnel.NAME.port": {
							"condition": "`vxlan`",
							"defaultdesc": "`0`",
							"longdesc": "",
							"shortdesc": "Specific port to use for the `vxlan` tunnel",
							"type": "integer"
						}
					},
					{
						"tunnel.NAME.protocol": {
							"condition": "standard mode",
							"longdesc": "Possible values are `vxlan` and `gre`.",
							"shortdesc": "Tunneling protocol",
							"type": "string"
						}
					},
					{
						"tunnel.NAME.remote": {
							"condition": "`gre` or `vxlan`",
							"longdesc": "",
							"required": "not required for multicast `vxlan`",
							"shortdesc": "Remote address for the tunnel",
							"type": "string"
						}
					},
					{
						"tunnel.NAME.ttl": {
							"condition": "`vxlan`",
							"defaultdesc": "`1`",
							"longdesc": "",
							"shortdesc": "Specific TTL to use for multicast routing topologies",
							"type": "string"
						}
					},
					{
						"user.*": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string"
						}
					}
				]
			}
		},
		"network-forward": {
			"forward-properties": {
				"keys": [
					{
						"config": {
							"longdesc": "The only supported keys are `target_address` and `user.*` custom keys.",
							"required": "no",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string set"
						}
					},
					{
						"description": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "Description of the network forward",
							"type": "string"
						}
					},
					{
						"listen_address": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "IP address to listen on",
							"type": "string"
						}
					},
					{
						"ports": {
							"longdesc": "See {ref}`network-forwards-port-specifications`.",
							"required": "no",
							"shortdesc": "List of port specifications",
							"type": "port list"
						}
					}
				]
			},
			"port-properties": {
				"keys": [
					{
						"description": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Description of the port or ports",
							"type": "string"
						}
					},
					{
						"listen_port": {
							"longdesc": "For example: `80,90-100`",
							"required": "yes",
							"shortdesc": "Listen port or ports",
							"type": "string"
						}
					},
					{
						"protocol": {
							"longdesc": " Possible values are `tcp` and `udp`.",
							"required": "yes",
							"shortdesc": "Protocol for the port or ports",
							"type": "string"
						}
					},
					{
						"target_address": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "IP address to forward to",
							"type": "string"
						}
					},
					{
						"target_port": {
							"defaultdesc": "same as `listen_port`",
							"longdesc": "For example: `70,80-90` or `90`",
							"required": "no",
							"shortdesc": "Target port or ports",
							"type": "string"
						}
					}
				]
			}
		},
		"network-load-balancer": {
			"load-balancer-backend-properties": {
				"keys": [
					{
						"description": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Description of the backend",
							"type": "string"
						}
					},
					{
						"name": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "Name of the backend",
							"type": "string"
						}
					},
					{
						"target_address": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "IP address to forward to",
							"type": "string"
						}
					},
					{
						"target_port": {
							"defaultdesc": "same as {config:option}`network-load-balancer-load-balancer-port-properties:listen_port`",
							"longdesc": "For example: `70,80-90` or `90`",
							"required": "no",
							"shortdesc": "Target port or ports",
							"type": "string"
						}
					}
				]
			},
			"load-balancer-port-properties": {
				"keys": [
					{
						"description": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Description of the port or ports",
							"type": "string"
						}
					},
					{
						"listen_port": {
							"longdesc": "For example: `80,90-100`",
							"required": "yes",
							"shortdesc": "Listen port or ports",
							"type": "string"
						}
					},
					{
						"protocol": {
							"longdesc": "Possible values are `tcp` and `udp`.",
							"required": "yes",
							"shortdesc": "Protocol for the port or ports",
							"type": "string"
						}
					},
					{
						"target_backend": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "Backend name or names to forward to",
							"type": "backend list"
						}
					}
				]
			},
			"load-balancer-properties": {
				"keys": [
					{
						"backends": {
							"longdesc": "See {ref}`network-load-balancers-backend-specifications`.",
							"required": "no",
							"shortdesc": "List of backend specifications",
							"type": "backend list"
						}
					},
					{
						"config": {
							"longdesc": "The only supported keys are `user.*` custom keys.",
							"required": "no",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string set"
						}
					},
					{
						"description": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Description of the network load balancer",
							"type": "string"
						}
					},
					{
						"listen_address": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "IP address to listen on",
							"type": "string"
						}
					},
					{
						"ports": {
							"longdesc": "See {ref}`network-load-balancers-port-specifications`.",
							"required": "no",
							"shortdesc": "List of port specifications",
							"type": "port list"
						}
					}
				]
			}
		},
		"network-macvlan": {
			"network-conf": {
				"keys": [
					{
						"gvrp": {
							"defaultdesc": "`false`",
							"longdesc": "This option specifies whether to register the VLAN using the GARP VLAN Registration Protocol.",
							"scope": "global",
							"shortdesc": "Whether to use GARP VLAN Registration Protocol",
							"type": "bool"
						}
					},
					{
						"maas.subnet.ipv4": {
							"condition": "IPv4 address; using the `network` property on the NIC",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "MAAS IPv4 subnet to register instances in",
							"type": "string"
						}
					},
					{
						"maas.subnet.ipv6": {
							"condition": "IPv4 address; using the `network` property on the NIC",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "MAAS IPv6 subnet to register instances in",
							"type": "string"
						}
					},
					{
						"mtu": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "MTU of the new interface",
							"type": "integer"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Parent interface to create `macvlan` NICs on",
							"type": "string"
						}
					},
					{
						"user.*": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string"
						}
					},
					{
						"vlan": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "VLAN ID to attach to",
							"type": "integer"
						}
					}
				]
			}
		},
		"network-ovn": {
			"network-conf": {
				"keys": [
					{
						"bridge.hwaddr": {
							"longdesc": "",
							"shortdesc": "MAC address for the bridge",
							"type": "string"
						}
					},
					{
						"bridge.mtu": {
							"defaultdesc": "`1442`",
							"longdesc": "The default value allows the host to host Geneve tunnels.",
							"shortdesc": "Bridge MTU",
							"type": "integer"
						}
					},
					{
						"dns.domain": {
							"defaultdesc": "`lxd`",
							"longdesc": "",
							"shortdesc": "Domain to advertise to DHCP clients and use for DNS resolution",
							"type": "string"
						}
					},
					{
						"dns.search": {
							"defaultdesc": "`dns.domain` value",
							"longdesc": "Specify a comma-separated list of domains.",
							"shortdesc": "Full domain search list",
							"type": "string"
						}
					},
					{
						"dns.zone.forward": {
							"longdesc": "Specify a comma-separated list of DNS zone names.",
							"shortdesc": "DNS zone names for forward DNS records",
							"type": "string"
						}
					},
					{
						"dns.zone.reverse.ipv4": {
							"longdesc": "",
							"shortdesc": "DNS zone name for IPv4 reverse DNS records",
							"type": "string"
						}
					},
					{
						"dns.zone.reverse.ipv6": {
							"longdesc": "",
							"shortdesc": "DNS zone name for IPv6 reverse DNS records",
							"type": "string"
						}
					},
					{
						"ipv4.address": {
							"condition": "standard mode",
							"defaultdesc": "initial value on creation: `auto`",
							"longdesc": "Use CIDR notation.\n\nYou can set the option to `none` to turn off IPv4, or to `auto` to generate a new random unused subnet.",
							"shortdesc": "IPv4 address for the OVN network",
							"type": "string"
						}
					},
					{
						"ipv4.dhcp": {
							"condition": "IPv4 address",
							"defaultdesc": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to allocate IPv4 addresses using DHCP",
							"type": "bool"
						}
					},
					{
						"ipv4.l3only": {
							"condition": "IPv4 address",
							"defaultdesc": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to enable layer 3 only mode for IPv4",
							"type": "bool"
						}
					},
					{
						"ipv4.nat": {
							"condition": "IPv4 address",
							"defaultdesc": "`false` (initial value on creation if `ipv4.address` is set to `auto`: `true`)",
							"longdesc": "",
							"shortdesc": "Whether to use NAT for IPv4",
							"type": "bool"
						}
					},
					{
						"ipv4.nat.address": {
							"condition": "IPv4 address; requires uplink `ovn.ingress_mode=routed`",
							"longdesc": "",
							"shortdesc": "Source address used for outbound traffic from the network",
							"type": "string"
						}
					},
					{
						"ipv6.address": {
							"condition": "standard mode",
							"defaultdesc": "initial value on creation: `auto`",
							"longdesc": "Use CIDR notation.\n\nYou can set the option to `none` to turn off IPv6, or to `auto` to generate a new random unused subnet.",
							"shortdesc": "IPv6 address for the OVN network",
							"type": "string"
						}
					},
					{
						"ipv6.dhcp": {
							"condition": "IPv6 address",
							"defaultdesc": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to provide additional network configuration over DHCP",
							"type": "bool"
						}
					},
					{
						"ipv6.dhcp.stateful": {
							"condition": "IPv6 DHCP",
							"defaultdesc": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to allocate IPv6 addresses using DHCP",
							"type": "bool"
						}
					},
					{
						"ipv6.l3only": {
							"condition": "IPv6 DHCP stateful",
							"defaultdesc": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to enable layer 3 only mode for IPv6",
							"type": "bool"
						}
					},
					{
						"ipv6.nat": {
							"condition": "IPv6 address",
							"defaultdesc": "`false` (initial value on creation if `ipv6.address` is set to `auto`: `true`)",
							"longdesc": "",
							"shortdesc": "Whether to use NAT for IPv6",
							"type": "bool"
						}
					},
					{
						"ipv6.nat.address": {
							"condition": "IPv6 address; requires uplink `ovn.ingress_mode=routed`",
							"longdesc": "",
							"shortdesc": "Source address used for outbound traffic from the network",
							"type": "string"
						}
					},
					{
						"network": {
							"longdesc": "",
							"shortdesc": "Uplink network to use for external network access",
							"type": "string"
						}
					},
					{
						"security.acls": {
							"longdesc": "Specify a comma-separated list of network ACLs.",
							"shortdesc": "Network ACLs to apply to NICs connected to this network",
							"type": "string"
						}
					},
					{
						"security.acls.default.egress.action": {
							"condition": "`security.acls`",
							"defaultdesc": "`reject`",
							"longdesc": "The specified action is used for all egress traffic that doesnâ€™t match any ACL rule.",
							"shortdesc": "Default action to use for egress traffic",
							"type": "string"
						}
					},
					{
						"security.acls.default.egress.logged": {
							"condition": "`security.acls`",
							"defaultdesc": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to log egress traffic that doesnâ€™t match any ACL rule",
							"type": "bool"
						}
					},
					{
						"security.acls.default.ingress.action": {
							"condition": "`security.acls`",
							"defaultdesc": "`reject`",
							"longdesc": "The specified action is used for all ingress traffic that doesnâ€™t match any ACL rule.",
							"shortdesc": "Default action to use for ingress traffic",
							"type": "string"
						}
					},
					{
						"security.acls.default.ingress.logged": {
							"condition": "`security.acls`",
							"defaultdesc": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to log ingress traffic that doesnâ€™t match any ACL rule",
							"type": "bool"
						}
					},
					{
						"user.*": {
							"longdesc": "",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string"
						}
					}
				]
			}
		},
		"network-peering": {
			"peering-properties": {
				"keys": [
					{
						"config": {
							"longdesc": "The only supported keys are `user.*` custom keys.",
							"required": "no",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string set"
						}
					},
					{
						"description": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Description of the network peering",
							"type": "string"
						}
					},
					{
						"name": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "Name of the network peering on the local network",
							"type": "string"
						}
					},
					{
						"status": {
							"longdesc": "Indicates if mutual peering exists with the target network.\nThis property is read-only and cannot be updated.",
							"required": "--",
							"shortdesc": "Status indicating if pending or created",
							"type": "string"
						}
					},
					{
						"target_network": {
							"longdesc": "This option must be set at create time.",
							"required": "yes",
							"shortdesc": "Which network to create a peering with",
							"type": "string"
						}
					},
					{
						"target_project": {
							"longdesc": "This option must be set at create time.",
							"required": "yes",
							"shortdesc": "Which project the target network exists in",
							"type": "string"
						}
					}
				]
			}
		},
		"network-physical": {
			"network-conf": {
				"keys": [
					{
						"bgp.peers.NAME.address": {
							"condition": "BGP server",
							"longdesc": "The address can be IPv4 or IPv6.",
							"scope": "global",
							"shortdesc": "Peer address for use by `ovn` downstream networks",
							"type": "string"
						}
					},
					{
						"bgp.peers.NAME.asn": {
							"condition": "BGP server",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Peer AS number for use by `ovn` downstream networks",
							"type": "integer"
						}
					},
					{
						"bgp.peers.NAME.holdtime": {
							"condition": "BGP server",
							"defaultdesc": "`180`",
							"longdesc": "Specify the peer session hold time in seconds.",
							"required": "no",
							"scope": "global",
							"shortdesc": "Peer session hold time",
							"type": "integer"
						}
					},
					{
						"bgp.peers.NAME.password": {
							"condition": "BGP server",
							"defaultdesc": "(no password)",
							"longdesc": "",
							"required": "no",
							"scope": "global",
							"shortdesc": "Peer session password for use by `ovn` downstream networks",
							"type": "string"
						}
					},
					{
						"dns.nameservers": {
							"condition": "standard mode",
							"longdesc": "Specify a list of DNS server IPs.",
							"scope": "global",
							"shortdesc": "DNS server IPs on physical network",
							"type": "string"
						}
					},
					{
						"gvrp": {
							"defaultdesc": "`false`",
							"longdesc": "This option specifies whether to register the VLAN using the GARP VLAN Registration Protocol.",
							"scope": "global",
							"shortdesc": "Whether to use GARP VLAN Registration Protocol",
							"type": "bool"
						}
					},
					{
						"ipv4.gateway": {
							"condition": "standard mode",
							"longdesc": "Use CIDR notation.",
							"scope": "global",
							"shortdesc": "IPv4 address for the gateway and network",
							"type": "string"
						}
					},
					{
						"ipv4.ovn.ranges": {
							"longdesc": "Specify a comma-separated list of IPv4 ranges in FIRST-LAST format.",
							"scope": "global",
							"shortdesc": "IPv4 ranges to use for child OVN network routers",
							"type": "string"
						}
					},
					{
						"ipv4.routes": {
							"condition": "IPv4 address",
							"longdesc": "Specify a comma-separated list of IPv4 CIDR subnets that can be used with child OVN network forwarders, load-balancers and {config:option}`device-nic-ovn-device-conf:ipv4.routes.external` setting.",
							"scope": "global",
							"shortdesc": "Additional IPv4 CIDR subnets",
							"type": "string"
						}
					},
					{
						"ipv4.routes.anycast": {
							"condition": "IPv4 address",
							"defaultdesc": "`false`",
							"longdesc": "If set to `true`, this option allows the overlapping routes to be used on multiple networks/NICs at the same time.",
							"scope": "global",
							"shortdesc": "Whether to allow IPv4 routes on multiple networks/NICs",
							"type": "bool"
						}
					},
					{
						"ipv6.gateway": {
							"condition": "standard mode",
							"longdesc": "Use CIDR notation.",
							"scope": "global",
							"shortdesc": "IPv6 address for the gateway and network",
							"type": "string"
						}
					},
					{
						"ipv6.ovn.ranges": {
							"longdesc": "Specify a comma-separated list of IPv6 ranges in FIRST-LAST format.",
							"scope": "global",
							"shortdesc": "IPv6 ranges to use for child OVN network routers",
							"type": "string"
						}
					},
					{
						"ipv6.routes": {
							"condition": "IPv6 address",
							"longdesc": "Specify a comma-separated list of IPv6 CIDR subnets that can be used with child OVN network forwarders, load-balancers and {config:option}`device-nic-ovn-device-conf:ipv6.routes.external` setting.",
							"scope": "global",
							"shortdesc": "Additional IPv6 CIDR subnets",
							"type": "string"
						}
					},
					{
						"ipv6.routes.anycast": {
							"condition": "IPv6 address",
							"defaultdesc": "`false`",
							"longdesc": "If set to `true`, this option allows the overlapping routes to be used on multiple networks/NICs at the same time.",
							"scope": "global",
							"shortdesc": "Whether to allow IPv6 routes on multiple networks/NICs",
							"type": "bool"
						}
					},
					{
						"maas.subnet.ipv4": {
							"condition": "IPv4 address; using the `network` property on the NIC",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "MAAS IPv4 subnet to register instances in",
							"type": "string"
						}
					},
					{
						"maas.subnet.ipv6": {
							"condition": "IPv6 address; using the `network` property on the NIC",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "MAAS IPv6 subnet to register instances in",
							"type": "string"
						}
					},
					{
						"mtu": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "MTU of the new interface",
							"type": "integer"
						}
					},
					{
						"ovn.ingress_mode": {
							"condition": "standard mode",
							"defaultdesc": "`l2proxy`",
							"longdesc": "Possible values are `l2proxy` (proxy ARP/NDP) and `routed`.",
							"scope": "global",
							"shortdesc": "How OVN NIC external IPs are advertised on uplink network",
							"type": "string"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Existing interface to use for network",
							"type": "string"
						}
					},
					{
						"user.*": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string"
						}
					},
					{
						"vlan": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "VLAN ID to attach to",
							"type": "integer"
						}
					}
				]
			}
		},
		"network-sriov": {
			"network-conf": {
				"keys": [
					{
						"maas.subnet.ipv4": {
							"condition": "IPv4 address; using the `network` property on the NIC",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "MAAS IPv4 subnet to register instances in",
							"type": "string"
						}
					},
					{
						"maas.subnet.ipv6": {
							"condition": "IPv6 address; using the `network` property on the NIC",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "MAAS IPv6 subnet to register instances in",
							"type": "string"
						}
					},
					{
						"mtu": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "MTU of the new interface",
							"type": "integer"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Parent interface to create `sriov` NICs on",
							"type": "string"
						}
					},
					{
						"user.*": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string"
						}
					},
					{
						"vlan": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "VLAN ID to attach to",
							"type": "integer"
						}
					}
				]
			}
		},
		"network-zone": {
			"config-options": {
				"keys": [
					{
						"dns.nameservers": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Comma-separated list of DNS server FQDNs (for NS records)",
							"type": "string set"
						}
					},
					{
						"network.nat": {
							"defaultdesc": "true",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Whether to generate records for NAT-ed subnets",
							"type": "bool"
						}
					},
					{
						"peers.NAME.address": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "IP address of a DNS server",
							"type": "string"
						}
					},
					{
						"peers.NAME.key": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "TSIG key for the server",
							"type": "string"
						}
					},
					{
						"user.*": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string"
						}
					}
				]
			},
			"record-properties": {
				"keys": [
					{
						"config": {
							"longdesc": "The only supported keys are `user.*` custom keys.",
							"required": "no",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string set"
						}
					},
					{
						"description": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Description of the record",
							"type": "string"
						}
					},
					{
						"entries": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "List of DNS entries",
							"type": "entry list"
						}
					},
					{
						"name": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "Unique name of the record",
							"type": "string"
						}
					}
				]
			}
		},
		"project": {
			"features": {
				"keys": [
					{
						"features.images": {
							"defaultdesc": "`false`",
							"initialvaluedesc": "`true`",
							"longdesc": "This setting applies to both images and image aliases.",
							"shortdesc": "Whether to use a separate set of images for the project",
							"type": "bool"
						}
					},
					{
						"features.networks": {
							"defaultdesc": "`false`",
							"initialvaluedesc": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to use a separate set of networks for the project",
							"type": "bool"
						}
					},
					{
						"features.networks.zones": {
							"defaultdesc": "`false`",
							"initialvaluedesc": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to use a separate set of network zones for the project",
							"type": "bool"
						}
					},
					{
						"features.profiles": {
							"defaultdesc": "`false`",
							"initialvaluedesc": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to use a separate set of profiles for the project",
							"type": "bool"
						}
					},
					{
						"features.storage.buckets": {
							"defaultdesc": "`false`",
							"initialvaluedesc": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to use a separate set of storage buckets for the project",
							"type": "bool"
						}
					},
					{
						"features.storage.volumes": {
							"defaultdesc": "`false`",
							"initialvaluedesc": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to use a separate set of storage volumes for the project",
							"type": "bool"
						}
					}
				]
			},
			"limits": {
				"keys": [
					{
						"limits.containers": {
							"longdesc": "",
							"shortdesc": "Maximum number of containers that can be created in the project",
							"type": "integer"
						}
					},
					{
						"limits.cpu": {
							"longdesc": "This value is the maximum value for the sum of the individual {config:option}`instance-resource-limits:limits.cpu` configurations set on the instances of the project.",
							"shortdesc": "Maximum number of CPUs to use in the project",
							"type": "integer"
						}
					},
					{
						"limits.disk": {
							"longdesc": "This value is the maximum value of the aggregate disk space used by all instance volumes, custom volumes, and images of the project.",
							"shortdesc": "Maximum disk space used by the project",
							"type": "string"
						}
					},
					{
						"limits.disk.pool.POOL_NAME": {
							"longdesc": "This value is the maximum value of the aggregate disk\nspace used by all instance volumes, custom volumes, and images of the\nproject on this specific storage pool.\n\nWhen set to 0, the pool is excluded from storage pool list for\nthe project.",
							"shortdesc": "Maximum disk space used by the project on this pool",
							"type": "string"
						}
					},
					{
						"limits.instances": {
							"longdesc": "",
							"shortdesc": "Maximum number of instances that can be created in the project",
							"type": "integer"
						}
					},
					{
						"limits.memory": {
							"longdesc": "The value is the maximum value for the sum of the individual {config:option}`instance-resource-limits:limits.memory` configurations set on the instances of the project.",
							"shortdesc": "Usage limit for the host's memory for the project",
							"type": "string"
						}
					},
					{
						"limits.networks": {
							"longdesc": "",
							"shortdesc": "Maximum number of networks that the project can have",
							"type": "integer"
						}
					},
					{
						"limits.processes": {
							"longdesc": "This value is the maximum value for the sum of the individual {config:option}`instance-resource-limits:limits.processes` configurations set on the instances of the project.",
							"shortdesc": "Maximum number of processes within the project",
							"type": "integer"
						}
					},
					{
						"limits.virtual-machines": {
							"longdesc": "",
							"shortdesc": "Maximum number of VMs that can be created in the project",
							"type": "integer"
						}
					}
				]
			},
			"restricted": {
				"keys": [
					{
						"restricted": {
							"defaultdesc": "`false`",
							"longdesc": "This option must be enabled to allow the `restricted.*` keys to take effect.\nTo temporarily remove the restrictions, you can disable this option instead of clearing the related keys.",
							"shortdesc": "Whether to block access to security-sensitive features",
							"type": "bool"
						}
					},
					{
						"restricted.backups": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent creating instance or volume backups",
							"type": "string"
						}
					},
					{
						"restricted.cluster.groups": {
							"longdesc": "If specified, this option prevents targeting cluster groups other than the provided ones.",
							"shortdesc": "Cluster groups that can be targeted",
							"type": "string"
						}
					},
					{
						"restricted.cluster.target": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.\nWhen set to `allow`, this option allows targeting of cluster members (either directly or via a group) when creating or moving instances.",
							"shortdesc": "Whether to prevent targeting of cluster members",
							"type": "string"
						}
					},
					{
						"restricted.containers.interception": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow`, `block`, or `full`.\nWhen set to `allow`, interception options that are usually safe are allowed.\nFile system mounting remains blocked.",
							"shortdesc": "Whether to prevent using system call interception options",
							"type": "string"
						}
					},
					{
						"restricted.containers.lowlevel": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.\nWhen set to `allow`, low-level container options like {config:option}`instance-raw:raw.lxc`, {config:option}`instance-raw:raw.idmap`, `volatile.*`, etc. can be used.",
							"shortdesc": "Whether to prevent using low-level container options",
							"type": "string"
						}
					},
					{
						"restricted.containers.nesting": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.\nWhen set to `allow`, {config:option}`instance-security:security.nesting` can be set to `true` for an instance.",
							"shortdesc": "Whether to prevent running nested LXD",
							"type": "string"
						}
					},
					{
						"restricted.containers.privilege": {
							"defaultdesc": "`unprivileged`",
							"longdesc": "Possible values are `unprivileged`, `isolated`, and `allow`.\n\n- When set to `unpriviliged`, this option prevents setting {config:option}`instance-security:security.privileged` to `true`.\n- When set to `isolated`, this option prevents setting {config:option}`instance-security:security.privileged` to `true` and forces using a unique idmap per container using {config:option}`instance-security:security.idmap.isolated` set to `true`.\n- When set to `allow`, there is no restriction.",
							"shortdesc": "Which settings for privileged containers to prevent",
							"type": "string"
						}
					},
					{
						"restricted.devices.disk": {
							"defaultdesc": "`managed`",
							"longdesc": "Possible values are `allow`, `block`, or `managed`.\n\n- When set to `block`, this option prevents using all disk devices except the root one.\n- When set to `managed`, this option allows using disk devices only if `pool=` is set.\n- When set to `allow`, there is no restriction on which disk devices can be used.\n\n  ```{important}\n  When allowing all disk devices, make sure to set\n  {config:option}`project-restricted:restricted.devices.disk.paths` to a list of\n  path prefixes that you want to allow.\n  If you do not restrict the allowed paths, users can attach any disk device, including\n  shifted devices (`disk` devices with [`shift`](devices-disk-options) set to `true`),\n  which can be used to gain root access to the system.\n  ```",
							"shortdesc": "Which disk devices can be used",
							"type": "string"
						}
					},
					{
						"restricted.devices.disk.paths": {
							"longdesc": "If {config:option}`project-restricted:restricted.devices.disk` is set to `allow`, this option controls which `source` can be used for `disk` devices.\nSpecify a comma-separated list of path prefixes that restrict the `source` setting.\nIf this option is left empty, all paths are allowed.",
							"shortdesc": "Which `source` can be used for `disk` devices",
							"type": "string"
						}
					},
					{
						"restricted.devices.gpu": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `gpu`",
							"type": "string"
						}
					},
					{
						"restricted.devices.infiniband": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `infiniband`",
							"type": "string"
						}
					},
					{
						"restricted.devices.nic": {
							"defaultdesc": "`managed`",
							"longdesc": "Possible values are `allow`, `block`, or `managed`.\n\n- When set to `block`, this option prevents using all network devices.\n- When set to `managed`, this option allows using network devices only if `network=` is set.\n- When set to `allow`, there is no restriction on which network devices can be used.",
							"shortdesc": "Which network devices can be used",
							"type": "string"
						}
					},
					{
						"restricted.devices.pci": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `pci`",
							"type": "string"
						}
					},
					{
						"restricted.devices.proxy": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `proxy`",
							"type": "string"
						}
					},
					{
						"restricted.devices.unix-block": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `unix-block`",
							"type": "string"
						}
					},
					{
						"restricted.devices.unix-char": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `unix-char`",
							"type": "string"
						}
					},
					{
						"restricted.devices.unix-hotplug": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `unix-hotplug`",
							"type": "string"
						}
					},
					{
						"restricted.devices.usb": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `usb`",
							"type": "string"
						}
					},
					{
						"restricted.idmap.gid": {
							"longdesc": "This option specifies the host GID ranges that are allowed in the instance's {config:option}`instance-raw:raw.idmap` setting.",
							"shortdesc": "Which host GID ranges are allowed in `raw.idmap`",
							"type": "string"
						}
					},
					{
						"restricted.idmap.uid": {
							"longdesc": "This option specifies the host UID ranges that are allowed in the instance's {config:option}`instance-raw:raw.idmap` setting.",
							"shortdesc": "Which host UID ranges are allowed in `raw.idmap`",
							"type": "string"
						}
					},
					{
						"restricted.networks.access": {
							"longdesc": "Specify a comma-delimited list of network names that are allowed for use in this project.\nIf this option is not set, all networks are accessible.\n\nNote that this setting depends on the {config:option}`project-restricted:restricted.devices.nic` setting.",
							"shortdesc": "Which network names are allowed for use in this project",
							"type": "string"
						}
					},
					{
						"restricted.networks.subnets": {
							"defaultdesc": "`block`",
							"longdesc": "Specify a comma-delimited list of CIDR network routes from the uplink network's {config:option}`network-physical-network-conf:ipv4.routes` {config:option}`network-physical-network-conf:ipv6.routes` that are allowed for use in this project.\nUse the form `\u003cuplink\u003e:\u003csubnet\u003e`.",
							"shortdesc": "Which network subnets are allocated for use in this project",
							"type": "string"
						}
					},
					{
						"restricted.networks.uplinks": {
							"defaultdesc": "`block`",
							"longdesc": "Specify a comma-delimited list of network names that can be used as uplink for networks in this project.",
							"shortdesc": "Which network names can be used as uplink in this project",
							"type": "string"
						}
					},
					{
						"restricted.networks.zones": {
							"defaultdesc": "`block`",
							"longdesc": "Specify a comma-delimited list of network zones that can be used (or something under them) in this project.",
							"shortdesc": "Which network zones can be used in this project",
							"type": "string"
						}
					},
					{
						"restricted.snapshots": {
							"defaultdesc": "`block`",
							"longdesc": "",
							"shortdesc": "Whether to prevent creating instance or volume snapshots",
							"type": "string"
						}
					},
					{
						"restricted.virtual-machines.lowlevel": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.\nWhen set to `allow`, low-level VM options like {config:option}`instance-raw:raw.qemu`, `volatile.*`, etc. can be used.",
							"shortdesc": "Whether to prevent using low-level VM options",
							"type": "string"
						}
					}
				]
			},
			"specific": {
				"keys": [
					{
						"backups.compression_algorithm": {
							"longdesc": "Specify which compression algorithm to use for backups in this project.\nPossible values are `bzip2`, `gzip`, `lzma`, `xz`, or `none`.",
							"shortdesc": "Compression algorithm to use for backups",
							"type": "string"
						}
					},
					{
						"images.auto_update_cached": {
							"longdesc": "",
							"shortdesc": "Whether to automatically update cached images in the project",
							"type": "bool"
						}
					},
					{
						"images.auto_update_interval": {
							"longdesc": "Specify the interval in hours.\nTo disable looking for updates to cached images, set this option to `0`.",
							"shortdesc": "Interval at which to look for updates to cached images",
							"type": "integer"
						}
					},
					{
						"images.compression_algorithm": {
							"longdesc": "Possible values are `bzip2`, `gzip`, `lzma`, `xz`, or `none`.",
							"shortdesc": "Compression algorithm to use for new images in the project",
							"type": "string"
						}
					},
					{
						"images.default_architecture": {
							"longdesc": "",
							"shortdesc": "Default architecture to use in a mixed-architecture cluster",
							"type": "string"
						}
					},
					{
						"images.remote_cache_expiry": {
							"longdesc": "Specify the number of days after which the unused cached image expires.",
							"shortdesc": "When an unused cached remote image is flushed in the project",
							"type": "integer"
						}
					},
					{
						"user.*": {
							"longdesc": "",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string"
						}
					}
				]
			}
		},
		"server": {
			"acme": {
				"keys": [
					{
						"acme.agree_tos": {
							"defaultdesc": "`false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Agree to ACME terms of service",
							"type": "bool"
						}
					},
					{
						"acme.ca_url": {
							"defaultdesc": "`https://acme-v02.api.letsencrypt.org/directory`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "URL to the directory resource of the ACME service",
							"type": "string"
						}
					},
					{
						"acme.domain": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Domain for which the certificate is issued",
							"type": "string"
						}
					},
					{
						"acme.email": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Email address used for the account registration",
							"type": "string"
						}
					}
				]
			},
			"cluster": {
				"keys": [
					{
						"cluster.healing_threshold": {
							"defaultdesc": "`0`",
							"longdesc": "Specify the number of seconds after which an offline cluster member is to be evacuated.\nTo disable evacuating offline members, set this option to `0`.",
							"scope": "global",
							"shortdesc": "Threshold when to evacuate an offline cluster member",
							"type": "integer"
						}
					},
					{
						"cluster.https_address": {
							"longdesc": "See {ref}`cluster-https-address`.",
							"scope": "local",
							"shortdesc": "Address to use for clustering traffic",
							"type": "string"
						}
					},
					{
						"cluster.images_minimal_replica": {
							"defaultdesc": "`3`",
							"longdesc": "Specify the minimal number of cluster members that keep a copy of a particular image.\nSet this option to `1` for no replication, or to `-1` to replicate images on all members.",
							"scope": "global",
							"shortdesc": "Number of cluster members that replicate an image",
							"type": "integer"
						}
					},
					{
						"cluster.join_token_expiry": {
							"defaultdesc": "`3H`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Time after which a cluster join token expires",
							"type": "string"
						}
					},
					{
						"cluster.max_standby": {
							"defaultdesc": "`2`",
							"longdesc": "Specify the maximum number of cluster members that are assigned the database stand-by role.\nThis must be a number between `0` and `5`.",
							"scope": "global",
							"shortdesc": "Number of database stand-by members",
							"type": "integer"
						}
					},
					{
						"cluster.max_voters": {
							"defaultdesc": "`3`",
							"longdesc": "Specify the maximum number of cluster members that are assigned the database voter role.\nThis must be an odd number \u003e= `3`.",
							"scope": "global",
							"shortdesc": "Number of database voter members",
							"type": "integer"
						}
					},
					{
						"cluster.offline_threshold": {
							"defaultdesc": "`20`",
							"longdesc": "Specify the number of seconds after which an unresponsive member is considered offline.",
							"scope": "global",
							"shortdesc": "Threshold when an unresponsive member is considered offline",
							"type": "integer"
						}
					}
				]
			},
			"core": {
				"keys": [
					{
						"core.bgp_address": {
							"longdesc": "See {ref}`network-bgp`.",
							"scope": "local",
							"shortdesc": "Address to bind the BGP server to",
							"type": "string"
						}
					},
					{
						"core.bgp_asn": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "BGP Autonomous System Number for the local server",
							"type": "string"
						}
					},
					{
						"core.bgp_routerid": {
							"longdesc": "The identifier must be formatted as an IPv4 address.",
							"scope": "local",
							"shortdesc": "A unique identifier for the BGP server",
							"type": "string"
						}
					},
					{
						"core.debug_address": {
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Address to bind the `pprof` debug server to (HTTP)",
							"type": "string"
						}
					},
					{
						"core.dns_address": {
							"longdesc": "See {ref}`network-dns-server`.",
							"scope": "local",
							"shortdesc": "Address to bind the authoritative DNS server to",
							"type": "string"
						}
					},
					{
						"core.https_address": {
							"longdesc": "See {ref}`server-expose`.",
							"scope": "local",
							"shortdesc": "Address to bind for the remote API (HTTPS)",
							"type": "string"
						}
					},
					{
						"core.https_allowed_credentials": {
							"defaultdesc": "`false`",
							"longdesc": "If enabled, the `Access-Control-Allow-Credentials` HTTP header value is set to `true`.",
							"scope": "global",
							"shortdesc": "Whether to set `Access-Control-Allow-Credentials`",
							"type": "bool"
						}
					},
					{
						"core.https_allowed_headers": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "`Access-Control-Allow-Headers` HTTP header value",
							"type": "string"
						}
					},
					{
						"core.https_allowed_methods": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "`Access-Control-Allow-Methods` HTTP header value",
							"type": "string"
						}
					},
					{
						"core.https_allowed_origin": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "`Access-Control-Allow-Origin` HTTP header value",
							"type": "string"
						}
					},
					{
						"core.https_trusted_proxy": {
							"longdesc": "Specify a comma-separated list of IP addresses of trusted servers that provide the client's address through the proxy connection header.",
							"scope": "global",
							"shortdesc": "Trusted servers to provide the client's address",
							"type": "string"
						}
					},
					{
						"core.metrics_address": {
							"longdesc": "See {ref}`metrics`.",
							"scope": "local",
							"shortdesc": "Address to bind the metrics server to (HTTPS)",
							"type": "string"
						}
					},
					{
						"core.metrics_authentication": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to enforce authentication on the metrics endpoint",
							"type": "bool"
						}
					},
					{
						"core.proxy_http": {
							"longdesc": "If this option is not specified, LXD falls back to the `HTTP_PROXY` environment variable (if set).",
							"scope": "global",
							"shortdesc": "HTTP proxy to use",
							"type": "string"
						}
					},
					{
						"core.proxy_https": {
							"longdesc": "If this option is not specified, LXD falls back to the `HTTPS_PROXY` environment variable (if set).",
							"scope": "global",
							"shortdesc": "HTTPS proxy to use",
							"type": "string"
						}
					},
					{
						"core.proxy_ignore_hosts": {
							"longdesc": "Specify this option in a similar format to `NO_PROXY` (for example, `1.2.3.4,1.2.3.5`)\n\nIf this option is not specified, LXD falls back to the `NO_PROXY` environment variable (if set).",
							"scope": "global",
							"shortdesc": "Hosts that don't need the proxy",
							"type": "string"
						}
					},
					{
						"core.remote_token_expiry": {
							"defaultdesc": "no expiry",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Time after which a remote add token expires",
							"type": "string"
						}
					},
					{
						"core.shutdown_timeout": {
							"defaultdesc": "`5`",
							"longdesc": "Specify the number of minutes to wait for running operations to complete before the LXD server shuts down.",
							"scope": "global",
							"shortdesc": "How long to wait before shutdown",
							"type": "integer"
						}
					},
					{
						"core.storage_buckets_address": {
							"longdesc": "See {ref}`howto-storage-buckets`.",
							"scope": "local",
							"shortdesc": "Address to bind the storage object server to (HTTPS)",
							"type": "string"
						}
					},
					{
						"core.syslog_socket": {
							"defaultdesc": "`false`",
							"longdesc": "Set this option to `true` to enable the syslog unixgram socket to receive log messages from external processes.",
							"scope": "local",
							"shortdesc": "Whether to enable the syslog unixgram socket listener",
							"type": "bool"
						}
					},
					{
						"core.trust_ca_certificates": {
							"defaultdesc": "`false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to automatically trust clients signed by the CA",
							"type": "bool"
						}
					}
				]
			},
			"images": {
				"keys": [
					{
						"images.auto_update_cached": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to automatically update cached images",
							"type": "bool"
						}
					},
					{
						"images.auto_update_interval": {
							"defaultdesc": "`6`",
							"longdesc": "Specify the interval in hours.\nTo disable looking for updates to cached images, set this option to `0`.",
							"scope": "global",
							"shortdesc": "Interval at which to look for updates to cached images",
							"type": "integer"
						}
					},
					{
						"images.compression_algorithm": {
							"defaultdesc": "`gzip`",
							"longdesc": "Possible values are `bzip2`, `gzip`, `lzma`, `xz`, or `none`.",
							"scope": "global",
							"shortdesc": "Compression algorithm to use for new images",
							"type": "string"
						}
					},
					{
						"images.default_architecture": {
							"longdesc": "",
							"shortdesc": "Default architecture to use in a mixed-architecture cluster",
							"type": "string"
						}
					},
					{
						"images.remote_cache_expiry": {
							"defaultdesc": "`10`",
							"longdesc": "Specify the number of days after which the unused cached image expires.",
							"scope": "global",
							"shortdesc": "When an unused cached remote image is flushed",
							"type": "integer"
						}
					}
				]
			},
			"loki": {
				"keys": [
					{
						"loki.api.ca_cert": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "CA certificate for the Loki server",
							"type": "string"
						}
					},
					{
						"loki.api.url": {
							"longdesc": "Specify the protocol, name or IP and port. For example `https://loki.example.com:3100`. LXD will automatically add the `/loki/api/v1/push` suffix so there's no need to add it here.",
							"scope": "global",
							"shortdesc": "URL to the Loki server",
							"type": "string"
						}
					},
					{
						"loki.auth.password": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Password used for Loki authentication",
							"type": "string"
						}
					},
					{
						"loki.auth.username": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "User name used for Loki authentication",
							"type": "string"
						}
					},
					{
						"loki.instance": {
							"defaultdesc": "Local server host name or cluster member name",
							"longdesc": "This allows replacing the default instance value (server host name) by a more relevant value like a cluster identifier.",
							"scope": "global",
							"shortdesc": "Name to use as the instance field in Loki events.",
							"type": "string"
						}
					},
					{
						"loki.labels": {
							"longdesc": "Specify a comma-separated list of values that should be used as labels for a Loki log entry.",
							"scope": "global",
							"shortdesc": "Labels for a Loki log entry",
							"type": "string"
						}
					},
					{
						"loki.loglevel": {
							"defaultdesc": "`info`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Minimum log level to send to the Loki server",
							"type": "string"
						}
					},
					{
						"loki.types": {
							"defaultdesc": "`lifecycle,logging`",
							"longdesc": "Specify a comma-separated list of events to send to the Loki server.\nThe events can be any combination of `lifecycle`, `logging`, and `ovn`.",
							"scope": "global",
							"shortdesc": "Events to send to the Loki server",
							"type": "string"
						}
					}
				]
			},
			"miscellaneous": {
				"keys": [
					{
						"backups.compression_algorithm": {
							"defaultdesc": "`gzip`",
							"longdesc": "Possible values are `bzip2`, `gzip`, `lzma`, `xz`, or `none`.",
							"scope": "global",
							"shortdesc": "Compression algorithm to use for backups",
							"type": "string"
						}
					},
					{
						"instances.migration.stateful": {
							"longdesc": "You can override this setting for relevant instances, either in the instance-specific configuration or through a profile.",
							"scope": "global",
							"shortdesc": "Whether to set `migration.stateful` to `true` for the instances",
							"type": "bool"
						}
					},
					{
						"instances.nic.host_name": {
							"defaultdesc": "`random`",
							"longdesc": "Possible values are `random` and `mac`.\n\nIf set to `random`, use the random host interface name as the host name.\nIf set to `mac`, generate a host name in the form `lxd\u003cmac_address\u003e` (MAC without leading two digits).",
							"scope": "global",
							"shortdesc": "How to set the host name for a NIC",
							"type": "string"
						}
					},
					{
						"instances.placement.scriptlet": {
							"longdesc": "When using custom automatic instance placement logic, this option stores the scriptlet.\nSee {ref}`clustering-instance-placement-scriptlet` for more information.",
							"scope": "global",
							"shortdesc": "Instance placement scriptlet for automatic instance placement",
							"type": "string"
						}
					},
					{
						"maas.api.key": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "API key to manage MAAS",
							"type": "string"
						}
					},
					{
						"maas.api.url": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "URL of the MAAS server",
							"type": "string"
						}
					},
					{
						"maas.machine": {
							"defaultdesc": "host name",
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Name of this LXD host in MAAS",
							"type": "string"
						}
					},
					{
						"network.ovn.ca_cert": {
							"defaultdesc": "Content of `/etc/ovn/ovn-central.crt` if present",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVN SSL certificate authority",
							"type": "string"
						}
					},
					{
						"network.ovn.client_cert": {
							"defaultdesc": "Content of `/etc/ovn/cert_host` if present",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVN SSL client certificate",
							"type": "string"
						}
					},
					{
						"network.ovn.client_key": {
							"defaultdesc": "Content of `/etc/ovn/key_host` if present",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVN SSL client key",
							"type": "string"
						}
					},
					{
						"network.ovn.integration_bridge": {
							"defaultdesc": "`br-int`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVS integration bridge to use for OVN networks",
							"type": "string"
						}
					},
					{
						"network.ovn.northbound_connection": {
							"defaultdesc": "`unix:/var/run/ovn/ovnnb_db.sock`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVN northbound database connection string",
							"type": "string"
						}
					},
					{
						"storage.backups_volume": {
							"longdesc": "Specify the volume using the syntax `POOL/VOLUME`.",
							"scope": "local",
							"shortdesc": "Volume to use to store backup tarballs",
							"type": "string"
						}
					},
					{
						"storage.images_volume": {
							"longdesc": "Specify the volume using the syntax `POOL/VOLUME`.",
							"scope": "local",
							"shortdesc": "Volume to use to store the image tarballs",
							"type": "string"
						}
					}
				]
			},
			"oidc": {
				"keys": [
					{
						"oidc.audience": {
							"longdesc": "This value is required by some providers.",
							"scope": "global",
							"shortdesc": "Expected audience value for the application",
							"type": "string"
						}
					},
					{
						"oidc.client.id": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OpenID Connect client ID",
							"type": "string"
						}
					},
					{
						"oidc.groups.claim": {
							"longdesc": "Specify a custom claim to be requested when performing OIDC flows.\nConfigure a corresponding custom claim in your identity provider and\nadd organization level groups to it. These can be mapped to LXD groups\nfor automatic access control.",
							"scope": "global",
							"shortdesc": "A claim used for mapping identity provider groups to LXD groups.",
							"type": "string"
						}
					},
					{
						"oidc.issuer": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OpenID Connect Discovery URL for the provider",
							"type": "string"
						}
					},
					{
						"oidc.scopes": {
							"longdesc": "Overwrite the default scopes that are requested during OIDC flows.\nIf not set, the flow will request oidc, offline_access, email,\nprofile, and if defined the oidc_groups_claim as scopes.",
							"scope": "global",
							"shortdesc": "Scopes requested during OIDC flows",
							"type": "string"
						}
					}
				]
			}
		},
		"storage-btrfs": {
			"bucket-conf": {
				"keys": [
					{
						"size": {
							"condition": "appropriate driver",
							"defaultdesc": "same as `volume.size`",
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Size/quota of the storage bucket",
							"type": "string"
						}
					}
				]
			},
			"pool-conf": {
				"keys": [
					{
						"btrfs.mount_options": {
							"defaultdesc": "`user_subvol_rm_allowed`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Mount options for block devices",
							"type": "string"
						}
					},
					{
						"size": {
							"defaultdesc": "auto (20% of free disk space, \u003e= 5 GiB and \u003c= 30 GiB)",
							"longdesc": "When creating loop-based pools, specify the size in bytes ({ref}`suffixes \u003cinstances-limit-units\u003e` are supported).\nYou can increase the size to grow the storage pool.\n\nThe default (`auto`) creates a storage pool that uses 20% of the free disk space,\nwith a minimum of 5 GiB and a maximum of 30 GiB.",
							"scope": "local",
							"shortdesc": "Size of the storage pool (for loop-based pools)",
							"type": "string"
						}
					},
					{
						"source": {
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Path to an existing block device, loop file, or Btrfs subvolume",
							"type": "string"
						}
					},
					{
						"source.wipe": {
							"defaultdesc": "`false`",
							"longdesc": "Set this option to `true` to wipe the block device specified in `source`\nprior to creating the storage pool.",
							"scope": "local",
							"shortdesc": "Whether to wipe the block device before creating the pool",
							"type": "bool"
						}
					}
				]
			},
			"volume-conf": {
				"keys": [
					{
						"security.shared": {
							"condition": "virtual-machine or custom block volume",
							"defaultdesc": "same as `volume.security.shared` or `false`",
							"longdesc": "Enabling this option allows sharing the volume across multiple instances despite the possibility of data loss.\n",
							"scope": "global",
							"shortdesc": "Enable volume sharing",
							"type": "bool"
						}
					},
					{
						"security.shifted": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.security.shifted` or `false`",
							"longdesc": "Enabling this option allows attaching the volume to multiple isolated instances.",
							"scope": "global",
							"shortdesc": "Enable ID shifting overlay",
							"type": "bool"
						}
					},
					{
						"security.unmapped": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.security.unmappped` or `false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Disable ID mapping for the volume",
							"type": "bool"
						}
					},
					{
						"size": {
							"condition": "appropriate driver",
							"defaultdesc": "same as `volume.size`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Size/quota of the storage volume",
							"type": "string"
						}
					},
					{
						"snapshots.expiry": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.snapshots.expiry`",
							"longdesc": "Specify an expression like `1M 2H 3d 4w 5m 6y`.",
							"scope": "global",
							"shortdesc": "When snapshots are to be deleted",
							"type": "string"
						}
					},
					{
						"snapshots.pattern": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.snapshots.pattern` or `snap%d`",
							"longdesc": "You can specify a naming template that is used for scheduled snapshots and unnamed snapshots.\n\nThe `snapshots.pattern` option takes a Pongo2 template string to format the snapshot name.\n\nTo add a time stamp to the snapshot name, use the Pongo2 context variable `creation_date`.\nMake sure to format the date in your template string to avoid forbidden characters in the snapshot name.\nFor example, set `snapshots.pattern` to `{{ creation_date|date:'2006-01-02_15-04-05' }}` to name the snapshots after their time of creation, down to the precision of a second.\n\nAnother way to avoid name collisions is to use the placeholder `%d` in the pattern.\nFor the first snapshot, the placeholder is replaced with `0`.\nFor subsequent snapshots, the existing snapshot names are taken into account to find the highest number at the placeholder's position.\nThis number is then incremented by one for the new name.",
							"scope": "global",
							"shortdesc": "Template for the snapshot name",
							"type": "string"
						}
					},
					{
						"snapshots.schedule": {
							"condition": "custom volume",
							"defaultdesc": "same as `snapshots.schedule`",
							"longdesc": "Specify either a cron expression (`\u003cminute\u003e \u003chour\u003e \u003cdom\u003e \u003cmonth\u003e \u003cdow\u003e`), a comma-separated list of schedule aliases (`@hourly`, `@daily`, `@midnight`, `@weekly`, `@monthly`, `@annually`, `@yearly`), or leave empty to disable automatic snapshots (the default).",
							"scope": "global",
							"shortdesc": "Schedule for automatic volume snapshots",
							"type": "string"
						}
					},
					{
						"volatile.uuid": {
							"defaultdesc": "random UUID",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "The volume's UUID",
							"type": "string"
						}
					}
				]
			}
		},
		"storage-ceph": {
			"pool-conf": {
				"keys": [
					{
						"ceph.cluster_name": {
							"defaultdesc": "`ceph`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Name of the Ceph cluster in which to create new storage pools",
							"type": "string"
						}
					},
					{
						"ceph.osd.data_pool_name": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Name of the OSD data pool",
							"type": "string"
						}
					},
					{
						"ceph.osd.pg_num": {
							"defaultdesc": "`32`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Number of placement groups for the OSD storage pool",
							"type": "string"
						}
					},
					{
						"ceph.osd.pool_name": {
							"defaultdesc": "name of the pool",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Name of the OSD storage pool",
							"type": "string"
						}
					},
					{
						"ceph.osd.pool_size": {
							"defaultdesc": "`3`",
							"longdesc": "This option specifies the name for the file metadata OSD pool that should be used when\ncreating a file system automatically.",
							"shortdesc": "Number of RADOS object replicas. Set to 1 for no replication.",
							"type": "string"
						}
					},
					{
						"ceph.rbd.clone_copy": {
							"defaultdesc": "`true`",
							"longdesc": "Enable this option to use RBD lightweight clones rather than full dataset copies.",
							"scope": "global",
							"shortdesc": "Whether to use RBD lightweight clones",
							"type": "bool"
						}
					},
					{
						"ceph.rbd.du": {
							"defaultdesc": "`true`",
							"longdesc": "This option specifies whether to use RBD `du` to obtain disk usage data for stopped instances.",
							"scope": "global",
							"shortdesc": "Whether to use RBD `du`",
							"type": "bool"
						}
					},
					{
						"ceph.rbd.features": {
							"defaultdesc": "`layering`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Comma-separated list of RBD features to enable on the volumes",
							"type": "string"
						}
					},
					{
						"ceph.user.name": {
							"defaultdesc": "`admin`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "The Ceph user to use when creating storage pools and volumes",
							"type": "string"
						}
					},
					{
						"source": {
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Existing OSD storage pool to use",
							"type": "string"
						}
					},
					{
						"volatile.pool.pristine": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether the pool was empty on creation time",
							"type": "string"
						}
					}
				]
			},
			"volume-conf": {
				"keys": [
					{
						"block.filesystem": {
							"condition": "block-based volume with content type `filesystem`",
							"defaultdesc": "same as `volume.block.filesystem`",
							"longdesc": "Valid options are: `btrfs`, `ext4`, `xfs`\nIf not set, `ext4` is assumed.",
							"scope": "global",
							"shortdesc": "File system of the storage volume",
							"type": "string"
						}
					},
					{
						"block.mount_options": {
							"condition": "block-based volume with content type `filesystem`",
							"defaultdesc": "same as `volume.block.mount_options`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Mount options for block-backed file system volumes",
							"type": "string"
						}
					},
					{
						"security.shared": {
							"condition": "virtual-machine or custom block volume",
							"defaultdesc": "same as `volume.security.shared` or `false`",
							"longdesc": "Enabling this option allows sharing the volume across multiple instances despite the possibility of data loss.\n",
							"scope": "global",
							"shortdesc": "Enable volume sharing",
							"type": "bool"
						}
					},
					{
						"security.shifted": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.security.shifted` or `false`",
							"longdesc": "Enabling this option allows attaching the volume to multiple isolated instances.",
							"scope": "global",
							"shortdesc": "Enable ID shifting overlay",
							"type": "bool"
						}
					},
					{
						"security.unmapped": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.security.unmappped` or `false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Disable ID mapping for the volume",
							"type": "bool"
						}
					},
					{
						"size": {
							"condition": "appropriate driver",
							"defaultdesc": "same as `volume.size`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Size/quota of the storage volume",
							"type": "string"
						}
					},
					{
						"snapshots.expiry": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.snapshots.expiry`",
							"longdesc": "Specify an expression like `1M 2H 3d 4w 5m 6y`.",
							"scope": "global",
							"shortdesc": "When snapshots are to be deleted",
							"type": "string"
						}
					},
					{
						"snapshots.pattern": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.snapshots.pattern` or `snap%d`",
							"longdesc": "You can specify a naming template that is used for scheduled snapshots and unnamed snapshots.\n\nThe `snapshots.pattern` option takes a Pongo2 template string to format the snapshot name.\n\nTo add a time stamp to the snapshot name, use the Pongo2 context variable `creation_date`.\nMake sure to format the date in your template string to avoid forbidden characters in the snapshot name.\nFor example, set `snapshots.pattern` to `{{ creation_date|date:'2006-01-02_15-04-05' }}` to name the snapshots after their time of creation, down to the precision of a second.\n\nAnother way to avoid name collisions is to use the placeholder `%d` in the pattern.\nFor the first snapshot, the placeholder is replaced with `0`.\nFor subsequent snapshots, the existing snapshot names are taken into account to find the highest number at the placeholder's position.\nThis number is then incremented by one for the new name.",
							"scope": "global",
							"shortdesc": "Template for the snapshot name",
							"type": "string"
						}
					},
					{
						"snapshots.schedule": {
							"condition": "custom volume",
							"defaultdesc": "same as `snapshots.schedule`",
							"longdesc": "Specify either a cron expression (`\u003cminute\u003e \u003chour\u003e \u003cdom\u003e \u003cmonth\u003e \u003cdow\u003e`), a comma-separated list of schedule aliases (`@hourly`, `@daily`, `@midnight`, `@weekly`, `@monthly`, `@annually`, `@yearly`), or leave empty to disable automatic snapshots (the default).",
							"scope": "global",
							"shortdesc": "Schedule for automatic volume snapshots",
							"type": "string"
						}
					},
					{
						"volatile.uuid": {
							"defaultdesc": "random UUID",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "The volume's UUID",
							"type": "string"
						}
					}
				]
			}
		},
		"storage-cephfs": {
			"pool-conf": {
				"keys": [
					{
						"cephfs.cluster_name": {
							"defaultdesc": "`ceph`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Name of the Ceph cluster that contains the CephFS file system",
							"type": "string"
						}
					},
					{
						"cephfs.create_missing": {
							"defaultdesc": "`false`",
							"longdesc": "Use this option if the CephFS file system does not exist yet.\nLXD will then automatically create the file system and the missing data and metadata OSD pools.",
							"scope": "global",
							"shortdesc": "Automatically create the CephFS file system",
							"type": "bool"
						}
					},
					{
						"cephfs.data_pool": {
							"longdesc": "This option specifies the name for the data OSD pool that should be used when creating\na file system automatically.",
							"scope": "global",
							"shortdesc": "Data OSD pool name",
							"type": "string"
						}
					},
					{
						"cephfs.fscache": {
							"defaultdesc": "`false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Enable use of kernel `fscache` and `cachefilesd`",
							"type": "bool"
						}
					},
					{
						"cephfs.meta_pool": {
							"longdesc": "This option specifies the name for the file metadata OSD pool that should be used when\ncreating a file system automatically.",
							"scope": "global",
							"shortdesc": "Metadata OSD pool name",
							"type": "string"
						}
					},
					{
						"cephfs.osd_pg_num": {
							"longdesc": "This option specifies the number of OSD pool placement groups (`pg_num`) to use\nwhen creating a missing OSD pool.",
							"scope": "global",
							"shortdesc": "Number of placement groups when creating missing OSD pools",
							"type": "string"
						}
					},
					{
						"cephfs.osd_pool_size": {
							"defaultdesc": "`3`",
							"longdesc": "This option specifies the number of OSD pool replicas to use\nwhen creating an OSD pool.",
							"shortdesc": "Number of RADOS object replicas. Set to 1 for no replication.",
							"type": "string"
						}
					},
					{
						"cephfs.path": {
							"defaultdesc": "`/`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "The base path for the CephFS mount",
							"type": "string"
						}
					},
					{
						"cephfs.user.name": {
							"defaultdesc": "`admin`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "The Ceph user to use",
							"type": "string"
						}
					},
					{
						"source": {
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Existing CephFS file system or file system path to use",
							"type": "string"
						}
					},
					{
						"volatile.pool.pristine": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether the CephFS file system was empty on creation time",
							"type": "string"
						}
					}
				]
			},
			"volume-conf": {
				"keys": [
					{
						"security.shifted": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.security.shifted` or `false`",
							"longdesc": "Enabling this option allows attaching the volume to multiple isolated instances.",
							"scope": "global",
							"shortdesc": "Enable ID shifting overlay",
							"type": "bool"
						}
					},
					{
						"security.unmapped": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.security.unmappped` or `false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Disable ID mapping for the volume",
							"type": "bool"
						}
					},
					{
						"size": {
							"condition": "appropriate driver",
							"defaultdesc": "same as `volume.size`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Size/quota of the storage volume",
							"type": "string"
						}
					},
					{
						"snapshots.expiry": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.snapshots.expiry`",
							"longdesc": "Specify an expression like `1M 2H 3d 4w 5m 6y`.",
							"scope": "global",
							"shortdesc": "When snapshots are to be deleted",
							"type": "string"
						}
					},
					{
						"snapshots.pattern": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.snapshots.pattern` or `snap%d`",
							"longdesc": "You can specify a naming template that is used for scheduled snapshots and unnamed snapshots.\n\nThe `snapshots.pattern` option takes a Pongo2 template string to format the snapshot name.\n\nTo add a time stamp to the snapshot name, use the Pongo2 context variable `creation_date`.\nMake sure to format the date in your template string to avoid forbidden characters in the snapshot name.\nFor example, set `snapshots.pattern` to `{{ creation_date|date:'2006-01-02_15-04-05' }}` to name the snapshots after their time of creation, down to the precision of a second.\n\nAnother way to avoid name collisions is to use the placeholder `%d` in the pattern.\nFor the first snapshot, the placeholder is replaced with `0`.\nFor subsequent snapshots, the existing snapshot names are taken into account to find the highest number at the placeholder's position.\nThis number is then incremented by one for the new name.",
							"scope": "global",
							"shortdesc": "Template for the snapshot name",
							"type": "string"
						}
					},
					{
						"snapshots.schedule": {
							"condition": "custom volume",
							"defaultdesc": "same as `snapshots.schedule`",
							"longdesc": "Specify either a cron expression (`\u003cminute\u003e \u003chour\u003e \u003cdom\u003e \u003cmonth\u003e \u003cdow\u003e`), a comma-separated list of schedule aliases (`@hourly`, `@daily`, `@midnight`, `@weekly`, `@monthly`, `@annually`, `@yearly`), or leave empty to disable automatic snapshots (the default).",
							"scope": "global",
							"shortdesc": "Schedule for automatic volume snapshots",
							"type": "string"
						}
					},
					{
						"volatile.uuid": {
							"defaultdesc": "random UUID",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "The volume's UUID",
							"type": "string"
						}
					}
				]
			}
		},
		"storage-cephobject": {
			"bucket-conf": {
				"keys": [
					{
						"size": {
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Quota of the storage bucket",
							"type": "string"
						}
					}
				]
			},
			"pool-conf": {
				"keys": [
					{
						"cephobject.bucket.name_prefix": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Prefix to add to bucket names in Ceph",
							"type": "string"
						}
					},
					{
						"cephobject.cluster_name": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "The Ceph cluster to use",
							"type": "string"
						}
					},
					{
						"cephobject.radosgw.endpoint": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "URL of the `radosgw` gateway process",
							"type": "string"
						}
					},
					{
						"cephobject.radosgw.endpoint_cert_file": {
							"longdesc": "Specify the path to the file that contains the TLS client certificate.",
							"scope": "global",
							"shortdesc": "TLS client certificate to use for endpoint communication",
							"type": "string"
						}
					},
					{
						"cephobject.user.name": {
							"defaultdesc": "`admin`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "The Ceph user to use",
							"type": "string"
						}
					},
					{
						"volatile.pool.pristine": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether the `radosgw` `lxd-admin` user existed at creation time",
							"type": "string"
						}
					}
				]
			}
		},
		"storage-dir": {
			"pool-conf": {
				"keys": [
					{
						"rsync.bwlimit": {
							"defaultdesc": "`0` (no limit)",
							"longdesc": "When `rsync` must be used to transfer storage entities, this option specifies the upper limit\nto be placed on the socket I/O.",
							"scope": "global",
							"shortdesc": "Upper limit on the socket I/O for `rsync`",
							"type": "string"
						}
					},
					{
						"rsync.compression": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to use compression while migrating storage pools",
							"type": "bool"
						}
					},
					{
						"source": {
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Path to an existing directory",
							"type": "string"
						}
					}
				]
			},
			"volume-conf": {
				"keys": [
					{
						"security.shared": {
							"condition": "virtual-machine or custom block volume",
							"defaultdesc": "same as `volume.security.shared` or `false`",
							"longdesc": "Enabling this option allows sharing the volume across multiple instances despite the possibility of data loss.\n",
							"scope": "global",
							"shortdesc": "Enable volume sharing",
							"type": "bool"
						}
					},
					{
						"security.shifted": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.security.shifted` or `false`",
							"longdesc": "Enabling this option allows attaching the volume to multiple isolated instances.",
							"scope": "global",
							"shortdesc": "Enable ID shifting overlay",
							"type": "bool"
						}
					},
					{
						"security.unmapped": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.security.unmappped` or `false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Disable ID mapping for the volume",
							"type": "bool"
						}
					},
					{
						"size": {
							"condition": "appropriate driver",
							"defaultdesc": "same as `volume.size`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Size/quota of the storage volume",
							"type": "string"
						}
					},
					{
						"snapshots.expiry": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.snapshots.expiry`",
							"longdesc": "Specify an expression like `1M 2H 3d 4w 5m 6y`.",
							"scope": "global",
							"shortdesc": "When snapshots are to be deleted",
							"type": "string"
						}
					},
					{
						"snapshots.pattern": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.snapshots.pattern` or `snap%d`",
							"longdesc": "You can specify a naming template that is used for scheduled snapshots and unnamed snapshots.\n\nThe `snapshots.pattern` option takes a Pongo2 template string to format the snapshot name.\n\nTo add a time stamp to the snapshot name, use the Pongo2 context variable `creation_date`.\nMake sure to format the date in your template string to avoid forbidden characters in the snapshot name.\nFor example, set `snapshots.pattern` to `{{ creation_date|date:'2006-01-02_15-04-05' }}` to name the snapshots after their time of creation, down to the precision of a second.\n\nAnother way to avoid name collisions is to use the placeholder `%d` in the pattern.\nFor the first snapshot, the placeholder is replaced with `0`.\nFor subsequent snapshots, the existing snapshot names are taken into account to find the highest number at the placeholder's position.\nThis number is then incremented by one for the new name.",
							"scope": "global",
							"shortdesc": "Template for the snapshot name",
							"type": "string"
						}
					},
					{
						"snapshots.schedule": {
							"condition": "custom volume",
							"defaultdesc": "same as `snapshots.schedule`",
							"longdesc": "Specify either a cron expression (`\u003cminute\u003e \u003chour\u003e \u003cdom\u003e \u003cmonth\u003e \u003cdow\u003e`), a comma-separated list of schedule aliases (`@hourly`, `@daily`, `@midnight`, `@weekly`, `@monthly`, `@annually`, `@yearly`), or leave empty to disable automatic snapshots (the default).",
							"scope": "global",
							"shortdesc": "Schedule for automatic volume snapshots",
							"type": "string"
						}
					},
					{
						"volatile.uuid": {
							"defaultdesc": "random UUID",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "The volume's UUID",
							"type": "string"
						}
					}
				]
			}
		},
		"storage-lvm": {
			"bucket-conf": {
				"keys": [
					{
						"size": {
							"condition": "appropriate driver",
							"defaultdesc": "same as `volume.size`",
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Size/quota of the storage bucket",
							"type": "string"
						}
					}
				]
			},
			"pool-conf": {
				"keys": [
					{
						"lvm.thinpool_metadata_size": {
							"defaultdesc": "`0` (auto)",
							"longdesc": "By default, LVM calculates an appropriate size.",
							"scope": "global",
							"shortdesc": "The size of the thin pool metadata volume",
							"type": "string"
						}
					},
					{
						"lvm.thinpool_name": {
							"defaultdesc": "`LXDThinPool`",
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Thin pool where volumes are created",
							"type": "string"
						}
					},
					{
						"lvm.use_thinpool": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether the storage pool uses a thin pool for logical volumes",
							"type": "bool"
						}
					},
					{
						"lvm.vg.force_reuse": {
							"defaultdesc": "`false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Force using an existing non-empty volume group",
							"type": "bool"
						}
					},
					{
						"lvm.vg_name": {
							"defaultdesc": "name of the pool",
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Name of the volume group to create",
							"type": "string"
						}
					},
					{
						"rsync.bwlimit": {
							"defaultdesc": "`0` (no limit)",
							"longdesc": "When `rsync` must be used to transfer storage entities, this option specifies the upper limit\nto be placed on the socket I/O.",
							"scope": "global",
							"shortdesc": "Upper limit on the socket I/O for `rsync`",
							"type": "string"
						}
					},
					{
						"rsync.compression": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to use compression while migrating storage pools",
							"type": "bool"
						}
					},
					{
						"size": {
							"defaultdesc": "auto (20% of free disk space, \u003e= 5 GiB and \u003c= 30 GiB)",
							"longdesc": "When creating loop-based pools, specify the size in bytes ({ref}`suffixes \u003cinstances-limit-units\u003e` are supported).\nYou can increase the size to grow the storage pool.\n\nThe default (`auto`) creates a storage pool that uses 20% of the free disk space,\nwith a minimum of 5 GiB and a maximum of 30 GiB.",
							"scope": "local",
							"shortdesc": "Size of the storage pool (for loop-based pools)",
							"type": "string"
						}
					},
					{
						"source": {
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Path to an existing block device, loop file, or LVM volume group",
							"type": "string"
						}
					},
					{
						"source.wipe": {
							"defaultdesc": "`false`",
							"longdesc": "Set this option to `true` to wipe the block device specified in `source`\nprior to creating the storage pool.",
							"scope": "local",
							"shortdesc": "Whether to wipe the block device before creating the pool",
							"type": "bool"
						}
					}
				]
			},
			"volume-conf": {
				"keys": [
					{
						"block.filesystem": {
							"condition": "block-based volume with content type `filesystem`",
							"defaultdesc": "same as `volume.block.filesystem`",
							"longdesc": "Valid options are: `btrfs`, `ext4`, `xfs`\nIf not set, `ext4` is assumed.",
							"scope": "global",
							"shortdesc": "File system of the storage volume",
							"type": "string"
						}
					},
					{
						"block.mount_options": {
							"condition": "block-based volume with content type `filesystem`",
							"defaultdesc": "same as `volume.block.mount_options`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Mount options for block-backed file system volumes",
							"type": "string"
						}
					},
					{
						"lvm.stripes": {
							"defaultdesc": "same as `volume.lvm.stripes`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Number of stripes to use for new volumes (or thin pool volume)",
							"type": "string"
						}
					},
					{
						"lvm.stripes.size": {
							"defaultdesc": "same as `volume.lvm.stripes.size`",
							"longdesc": "The size must be at least 4096 bytes, and a multiple of 512 bytes.",
							"scope": "global",
							"shortdesc": "Size of stripes to use",
							"type": "string"
						}
					},
					{
						"security.shared": {
							"condition": "virtual-machine or custom block volume",
							"defaultdesc": "same as `volume.security.shared` or `false`",
							"longdesc": "Enabling this option allows sharing the volume across multiple instances despite the possibility of data loss.\n",
							"scope": "global",
							"shortdesc": "Enable volume sharing",
							"type": "bool"
						}
					},
					{
						"security.shifted": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.security.shifted` or `false`",
							"longdesc": "Enabling this option allows attaching the volume to multiple isolated instances.",
							"scope": "global",
							"shortdesc": "Enable ID shifting overlay",
							"type": "bool"
						}
					},
					{
						"security.unmapped": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.security.unmappped` or `false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Disable ID mapping for the volume",
							"type": "bool"
						}
					},
					{
						"size": {
							"condition": "appropriate driver",
							"defaultdesc": "same as `volume.size`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Size/quota of the storage volume",
							"type": "string"
						}
					},
					{
						"snapshots.expiry": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.snapshots.expiry`",
							"longdesc": "Specify an expression like `1M 2H 3d 4w 5m 6y`.",
							"scope": "global",
							"shortdesc": "When snapshots are to be deleted",
							"type": "string"
						}
					},
					{
						"snapshots.pattern": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.snapshots.pattern` or `snap%d`",
							"longdesc": "You can specify a naming template that is used for scheduled snapshots and unnamed snapshots.\n\nThe `snapshots.pattern` option takes a Pongo2 template string to format the snapshot name.\n\nTo add a time stamp to the snapshot name, use the Pongo2 context variable `creation_date`.\nMake sure to format the date in your template string to avoid forbidden characters in the snapshot name.\nFor example, set `snapshots.pattern` to `{{ creation_date|date:'2006-01-02_15-04-05' }}` to name the snapshots after their time of creation, down to the precision of a second.\n\nAnother way to avoid name collisions is to use the placeholder `%d` in the pattern.\nFor the first snapshot, the placeholder is replaced with `0`.\nFor subsequent snapshots, the existing snapshot names are taken into account to find the highest number at the placeholder's position.\nThis number is then incremented by one for the new name.",
							"scope": "global",
							"shortdesc": "Template for the snapshot name",
							"type": "string"
						}
					},
					{
						"snapshots.schedule": {
							"condition": "custom volume",
							"defaultdesc": "same as `snapshots.schedule`",
							"longdesc": "Specify either a cron expression (`\u003cminute\u003e \u003chour\u003e \u003cdom\u003e \u003cmonth\u003e \u003cdow\u003e`), a comma-separated list of schedule aliases (`@hourly`, `@daily`, `@midnight`, `@weekly`, `@monthly`, `@annually`, `@yearly`), or leave empty to disable automatic snapshots (the default).",
							"scope": "global",
							"shortdesc": "Schedule for automatic volume snapshots",
							"type": "string"
						}
					},
					{
						"volatile.uuid": {
							"defaultdesc": "random UUID",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "The volume's UUID",
							"type": "string"
						}
					}
				]
			}
		},
		"storage-powerflex": {
			"pool-conf": {
				"keys": [
					{
						"powerflex.clone_copy": {
							"defaultdesc": "`true`",
							"longdesc": "If this option is set to `true`, PowerFlex makes a non-sparse copy when creating a snapshot of an instance or custom volume.\nSee {ref}`storage-powerflex-limitations` for more information.",
							"scope": "global",
							"shortdesc": "Whether to use non-sparse copies for snapshots",
							"type": "bool"
						}
					},
					{
						"powerflex.domain": {
							"longdesc": "This option is required only if {config:option}`storage-powerflex-pool-conf:powerflex.pool` is specified using its name.",
							"scope": "global",
							"shortdesc": "Name of the PowerFlex protection domain",
							"type": "string"
						}
					},
					{
						"powerflex.gateway": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Address of the PowerFlex Gateway",
							"type": "string"
						}
					},
					{
						"powerflex.gateway.verify": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to verify the PowerFlex Gateway's certificate",
							"type": "bool"
						}
					},
					{
						"powerflex.mode": {
							"defaultdesc": "the discovered mode",
							"longdesc": "The mode gets discovered automatically if the system provides the necessary kernel modules.\nThis can be either `nvme` or `sdc`.",
							"scope": "global",
							"shortdesc": "How volumes are mapped to the local server",
							"type": "string"
						}
					},
					{
						"powerflex.pool": {
							"longdesc": "If you want to specify the storage pool via its name, also set {config:option}`storage-powerflex-pool-conf:powerflex.domain`.",
							"scope": "global",
							"shortdesc": "ID of the PowerFlex storage pool",
							"type": "string"
						}
					},
					{
						"powerflex.sdt": {
							"defaultdesc": "one of the SDT",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "PowerFlex NVMe/TCP SDT",
							"type": "string"
						}
					},
					{
						"powerflex.user.name": {
							"defaultdesc": "`admin`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "User for PowerFlex Gateway authentication",
							"type": "string"
						}
					},
					{
						"powerflex.user.password": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Password for PowerFlex Gateway authentication",
							"type": "string"
						}
					},
					{
						"rsync.bwlimit": {
							"defaultdesc": "`0` (no limit)",
							"longdesc": "When `rsync` must be used to transfer storage entities, this option specifies the upper limit\nto be placed on the socket I/O.",
							"scope": "global",
							"shortdesc": "Upper limit on the socket I/O for `rsync`",
							"type": "string"
						}
					},
					{
						"rsync.compression": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to use compression while migrating storage pools",
							"type": "bool"
						}
					},
					{
						"volume.size": {
							"defaultdesc": "`8GiB`",
							"longdesc": "The size must be in multiples of 8 GiB.\nSee {ref}`storage-powerflex-limitations` for more information.",
							"scope": "global",
							"shortdesc": "Size/quota of the storage volume",
							"type": "string"
						}
					}
				]
			},
			"volume-conf": {
				"keys": [
					{
						"block.filesystem": {
							"condition": "block-based volume with content type `filesystem`",
							"defaultdesc": "same as `volume.block.filesystem`",
							"longdesc": "Valid options are: `btrfs`, `ext4`, `xfs`\nIf not set, `ext4` is assumed.",
							"scope": "global",
							"shortdesc": "File system of the storage volume",
							"type": "string"
						}
					},
					{
						"block.mount_options": {
							"condition": "block-based volume with content type `filesystem`",
							"defaultdesc": "same as `volume.block.mount_options`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Mount options for block-backed file system volumes",
							"type": "string"
						}
					},
					{
						"block.type": {
							"defaultdesc": "same as `volume.block.type` or `thick`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to create a `thin` or `thick` provisioned volume",
							"type": "string"
						}
					},
					{
						"security.shared": {
							"condition": "virtual-machine or custom block volume",
							"defaultdesc": "same as `volume.security.shared` or `false`",
							"longdesc": "Enabling this option allows sharing the volume across multiple instances despite the possibility of data loss.\n",
							"scope": "global",
							"shortdesc": "Enable volume sharing",
							"type": "bool"
						}
					},
					{
						"security.shifted": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.security.shifted` or `false`",
							"longdesc": "Enabling this option allows attaching the volume to multiple isolated instances.",
							"scope": "global",
							"shortdesc": "Enable ID shifting overlay",
							"type": "bool"
						}
					},
					{
						"security.unmapped": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.security.unmappped` or `false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Disable ID mapping for the volume",
							"type": "bool"
						}
					},
					{
						"size": {
							"defaultdesc": "same as `volume.size`",
							"longdesc": "The size must be in multiples of 8 GiB.\nSee {ref}`storage-powerflex-limitations` for more information.",
							"scope": "global",
							"shortdesc": "Size/quota of the storage volume",
							"type": "string"
						}
					},
					{
						"snapshots.expiry": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.snapshots.expiry`",
							"longdesc": "Specify an expression like `1M 2H 3d 4w 5m 6y`.",
							"scope": "global",
							"shortdesc": "When snapshots are to be deleted",
							"type": "string"
						}
					},
					{
						"snapshots.pattern": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.snapshots.pattern` or `snap%d`",
							"longdesc": "You can specify a naming template that is used for scheduled snapshots and unnamed snapshots.\n\nThe `snapshots.pattern` option takes a Pongo2 template string to format the snapshot name.\n\nTo add a time stamp to the snapshot name, use the Pongo2 context variable `creation_date`.\nMake sure to format the date in your template string to avoid forbidden characters in the snapshot name.\nFor example, set `snapshots.pattern` to `{{ creation_date|date:'2006-01-02_15-04-05' }}` to name the snapshots after their time of creation, down to the precision of a second.\n\nAnother way to avoid name collisions is to use the placeholder `%d` in the pattern.\nFor the first snapshot, the placeholder is replaced with `0`.\nFor subsequent snapshots, the existing snapshot names are taken into account to find the highest number at the placeholder's position.\nThis number is then incremented by one for the new name.",
							"scope": "global",
							"shortdesc": "Template for the snapshot name",
							"type": "string"
						}
					},
					{
						"snapshots.schedule": {
							"condition": "custom volume",
							"defaultdesc": "same as `snapshots.schedule`",
							"longdesc": "Specify either a cron expression (`\u003cminute\u003e \u003chour\u003e \u003cdom\u003e \u003cmonth\u003e \u003cdow\u003e`), a comma-separated list of schedule aliases (`@hourly`, `@daily`, `@midnight`, `@weekly`, `@monthly`, `@annually`, `@yearly`), or leave empty to disable automatic snapshots (the default).",
							"scope": "global",
							"shortdesc": "Schedule for automatic volume snapshots",
							"type": "string"
						}
					},
					{
						"volatile.uuid": {
							"defaultdesc": "random UUID",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "The volume's UUID",
							"type": "string"
						}
					}
				]
			}
		},
		"storage-zfs": {
			"bucket-conf": {
				"keys": [
					{
						"size": {
							"condition": "appropriate driver",
							"defaultdesc": "same as `volume.size`",
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Size/quota of the storage bucket",
							"type": "string"
						}
					}
				]
			},
			"pool-conf": {
				"keys": [
					{
						"size": {
							"defaultdesc": "auto (20% of free disk space, \u003e= 5 GiB and \u003c= 30 GiB)",
							"longdesc": "When creating loop-based pools, specify the size in bytes ({ref}`suffixes \u003cinstances-limit-units\u003e` are supported).\nYou can increase the size to grow the storage pool.\n\nThe default (`auto`) creates a storage pool that uses 20% of the free disk space,\nwith a minimum of 5 GiB and a maximum of 30 GiB.",
							"scope": "local",
							"shortdesc": "Size of the storage pool (for loop-based pools)",
							"type": "string"
						}
					},
					{
						"source": {
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Path to an existing block device, loop file, or ZFS dataset/pool",
							"type": "string"
						}
					},
					{
						"source.wipe": {
							"defaultdesc": "`false`",
							"longdesc": "Set this option to `true` to wipe the block device specified in `source`\nprior to creating the storage pool.",
							"scope": "local",
							"shortdesc": "Whether to wipe the block device before creating the pool",
							"type": "bool"
						}
					},
					{
						"zfs.clone_copy": {
							"defaultdesc": "`true`",
							"longdesc": "Set this option to `true` or `false` to enable or disable using ZFS lightweight clones rather\nthan full dataset copies.\nSet the option to `rebase` to copy based on the initial image.",
							"scope": "global",
							"shortdesc": "Whether to use ZFS lightweight clones",
							"type": "string"
						}
					},
					{
						"zfs.export": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Disable zpool export while an unmount is being performed",
							"type": "bool"
						}
					},
					{
						"zfs.pool_name": {
							"defaultdesc": "name of the pool",
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Name of the zpool",
							"type": "string"
						}
					}
				]
			},
			"volume-conf": {
				"keys": [
					{
						"block.filesystem": {
							"condition": "block-based volume with content type `filesystem` (`zfs.block_mode` enabled)",
							"defaultdesc": "same as `volume.block.filesystem`",
							"longdesc": "Valid options are: `btrfs`, `ext4`, `xfs`\nIf not set, `ext4` is assumed.",
							"scope": "global",
							"shortdesc": "File system of the storage volume",
							"type": "string"
						}
					},
					{
						"block.mount_options": {
							"condition": "block-based volume with content type `filesystem` (`zfs.block_mode` enabled)",
							"defaultdesc": "same as `volume.block.mount_options`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Mount options for block-backed file system volumes",
							"type": "string"
						}
					},
					{
						"security.shared": {
							"condition": "virtual-machine or custom block volume",
							"defaultdesc": "same as `volume.security.shared` or `false`",
							"longdesc": "Enabling this option allows sharing the volume across multiple instances despite the possibility of data loss.\n",
							"scope": "global",
							"shortdesc": "Enable volume sharing",
							"type": "bool"
						}
					},
					{
						"security.shifted": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.security.shifted` or `false`",
							"longdesc": "Enabling this option allows attaching the volume to multiple isolated instances.",
							"scope": "global",
							"shortdesc": "Enable ID shifting overlay",
							"type": "bool"
						}
					},
					{
						"security.unmapped": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.security.unmappped` or `false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Disable ID mapping for the volume",
							"type": "bool"
						}
					},
					{
						"size": {
							"condition": "appropriate driver",
							"defaultdesc": "same as `volume.size`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Size/quota of the storage volume",
							"type": "string"
						}
					},
					{
						"snapshots.expiry": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.snapshots.expiry`",
							"longdesc": "Specify an expression like `1M 2H 3d 4w 5m 6y`.",
							"scope": "global",
							"shortdesc": "When snapshots are to be deleted",
							"type": "string"
						}
					},
					{
						"snapshots.pattern": {
							"condition": "custom volume",
							"defaultdesc": "same as `volume.snapshots.pattern` or `snap%d`",
							"longdesc": "You can specify a naming template that is used for scheduled snapshots and unnamed snapshots.\n\nThe `snapshots.pattern` option takes a Pongo2 template string to format the snapshot name.\n\nTo add a time stamp to the snapshot name, use the Pongo2 context variable `creation_date`.\nMake sure to format the date in your template string to avoid forbidden characters in the snapshot name.\nFor example, set `snapshots.pattern` to `{{ creation_date|date:'2006-01-02_15-04-05' }}` to name the snapshots after their time of creation, down to the precision of a second.\n\nAnother way to avoid name collisions is to use the placeholder `%d` in the pattern.\nFor the first snapshot, the placeholder is replaced with `0`.\nFor subsequent snapshots, the existing snapshot names are taken into account to find the highest number at the placeholder's position.\nThis number is then incremented by one for the new name.",
							"scope": "global",
							"shortdesc": "Template for the snapshot name",
							"type": "string"
						}
					},
					{
						"snapshots.schedule": {
							"condition": "custom volume",
							"defaultdesc": "same as `snapshots.schedule`",
							"longdesc": "Specify either a cron expression (`\u003cminute\u003e \u003chour\u003e \u003cdom\u003e \u003cmonth\u003e \u003cdow\u003e`), a comma-separated list of schedule aliases (`@hourly`, `@daily`, `@midnight`, `@weekly`, `@monthly`, `@annually`, `@yearly`), or leave empty to disable automatic snapshots (the default).",
							"scope": "global",
							"shortdesc": "Schedule for automatic volume snapshots",
							"type": "string"
						}
					},
					{
						"volatile.uuid": {
							"defaultdesc": "random UUID",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "The volume's UUID",
							"type": "string"
						}
					},
					{
						"zfs.block_mode": {
							"defaultdesc": "same as `volume.zfs.block_mode`",
							"longdesc": "`zfs.block_mode` can be set only for custom storage volumes.\nTo enable ZFS block mode for all storage volumes in the pool, including instance volumes,\nuse `volume.zfs.block_mode`.",
							"scope": "global",
							"shortdesc": "Whether to use a formatted `zvol` rather than a dataset",
							"type": "bool"
						}
					},
					{
						"zfs.blocksize": {
							"defaultdesc": "same as `volume.zfs.blocksize`",
							"longdesc": "The size must be between 512 bytes and 16 MiB and must be a power of 2.\nFor a block volume, a maximum value of 128 KiB will be used even if a higher value is set.\n\nDepending on the value of {config:option}`storage-zfs-volume-conf:zfs.block_mode`,\nthe specified size is used to set either `volblocksize` or `recordsize` in ZFS.",
							"scope": "global",
							"shortdesc": "Size of the ZFS block",
							"type": "string"
						}
					},
					{
						"zfs.delegate": {
							"condition": "ZFS 2.2 or higher",
							"defaultdesc": "same as `volume.zfs.delegate`",
							"longdesc": "This option controls whether to delegate the ZFS dataset and anything underneath it to the\ncontainer or containers that use it. When used in conjunction with\n{config:option}`instance-security:security.nesting`, this allows\nusing the `zfs` command in the container.",
							"scope": "global",
							"shortdesc": "Whether to delegate the ZFS dataset",
							"type": "bool"
						}
					},
					{
						"zfs.remove_snapshots": {
							"defaultdesc": "same as `volume.zfs.remove_snapshots` or `false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Remove snapshots as needed",
							"type": "bool"
						}
					},
					{
						"zfs.reserve_space": {
							"defaultdesc": "same as `volume.zfs.reserve_space` or `false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Use `reservation`/`refreservation` along with `quota`/`refquota`",
							"type": "bool"
						}
					},
					{
						"zfs.use_refquota": {
							"defaultdesc": "same as `volume.zfs.use_refquota` or `false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Use `refquota` instead of `quota` for space",
							"type": "bool"
						}
					}
				]
			}
		}
	},
	"entities": {
		"certificate": {
			"project_specific": false,
			"entitlements": [
				{
					"name": "can_view",
					"description": "Grants permission to view the certificate."
				},
				{
					"name": "can_edit",
					"description": "Grants permission to edit the certificate."
				},
				{
					"name": "can_delete",
					"description": "Grants permission to delete the certificate."
				}
			]
		},
		"group": {
			"project_specific": false,
			"entitlements": [
				{
					"name": "can_view",
					"description": "Grants permission to view the group. Identities can always view groups that they are a member of."
				},
				{
					"name": "can_edit",
					"description": "Grants permission to edit the group."
				},
				{
					"name": "can_delete",
					"description": "Grants permission to delete the group."
				}
			]
		},
		"identity": {
			"project_specific": false,
			"entitlements": [
				{
					"name": "can_view",
					"description": "Grants permission to view the identity."
				},
				{
					"name": "can_edit",
					"description": "Grants permission to edit the identity."
				},
				{
					"name": "can_delete",
					"description": "Grants permission to delete the identity."
				}
			]
		},
		"identity_provider_group": {
			"project_specific": false,
			"entitlements": [
				{
					"name": "can_view",
					"description": "Grants permission to view the identity provider group."
				},
				{
					"name": "can_edit",
					"description": "Grants permission to edit the identity provider group."
				},
				{
					"name": "can_delete",
					"description": "Grants permission to delete the identity provider group."
				}
			]
		},
		"image": {
			"project_specific": true,
			"entitlements": [
				{
					"name": "can_edit",
					"description": "Grants permission to edit the image."
				},
				{
					"name": "can_delete",
					"description": "Grants permission to delete the image."
				},
				{
					"name": "can_view",
					"description": "Grants permission to view the image."
				}
			]
		},
		"image_alias": {
			"project_specific": true,
			"entitlements": [
				{
					"name": "can_edit",
					"description": "Grants permission to edit the image alias."
				},
				{
					"name": "can_delete",
					"description": "Grants permission to delete the image alias."
				},
				{
					"name": "can_view",
					"description": "Grants permission to view the image alias."
				}
			]
		},
		"instance": {
			"project_specific": true,
			"entitlements": [
				{
					"name": "user",
					"description": "Grants permission to view the instance, to access files, and to start a terminal or console session."
				},
				{
					"name": "operator",
					"description": "Grants permission to view the instance, to access files, start a terminal or console session, and to manage snapshots and backups."
				},
				{
					"name": "can_edit",
					"description": "Grants permission to edit the instance."
				},
				{
					"name": "can_delete",
					"description": "Grants permission to delete the instance."
				},
				{
					"name": "can_view",
					"description": "Grants permission to view the instance and any snapshots or backups it might have."
				},
				{
					"name": "can_update_state",
					"description": "Grants permission to change the instance state."
				},
				{
					"name": "can_manage_snapshots",
					"description": "Grants permission to create and delete snapshots of the instance."
				},
				{
					"name": "can_manage_backups",
					"description": "Grants permission to create and delete backups of the instance."
				},
				{
					"name": "can_connect_sftp",
					"description": "Grants permission to get an SFTP client for the instance."
				},
				{
					"name": "can_access_files",
					"description": "Grants permission to push or pull files into or out of the instance."
				},
				{
					"name": "can_access_console",
					"description": "Grants permission to start a console session."
				},
				{
					"name": "can_exec",
					"description": "Grants permission to start a terminal session."
				}
			]
		},
		"network": {
			"project_specific": true,
			"entitlements": [
				{
					"name": "can_edit",
					"description": "Grants permission to edit the network."
				},
				{
					"name": "can_delete",
					"description": "Grants permission to delete the network."
				},
				{
					"name": "can_view",
					"description": "Grants permission to view the network."
				}
			]
		},
		"network_acl": {
			"project_specific": true,
			"entitlements": [
				{
					"name": "can_edit",
					"description": "Grants permission to edit the network ACL."
				},
				{
					"name": "can_delete",
					"description": "Grants permission to delete the network ACL."
				},
				{
					"name": "can_view",
					"description": "Grants permission to view the network ACL."
				}
			]
		},
		"network_zone": {
			"project_specific": true,
			"entitlements": [
				{
					"name": "can_edit",
					"description": "Grants permission to edit the network zone."
				},
				{
					"name": "can_delete",
					"description": "Grants permission to delete the network zone."
				},
				{
					"name": "can_view",
					"description": "Grants permission to view the network zone."
				}
			]
		},
		"profile": {
			"project_specific": true,
			"entitlements": [
				{
					"name": "can_edit",
					"description": "Grants permission to edit the profile."
				},
				{
					"name": "can_delete",
					"description": "Grants permission to delete the profile."
				},
				{
					"name": "can_view",
					"description": "Grants permission to view the profile."
				}
			]
		},
		"project": {
			"project_specific": false,
			"entitlements": [
				{
					"name": "operator",
					"description": "Grants permission to create, view, edit, and delete all resources belonging to the project, but does not grant permission to edit the project configuration itself."
				},
				{
					"name": "viewer",
					"description": "Grants permission to view all resources belonging to the project."
				},
				{
					"name": "can_view",
					"description": "Grants permission to view the project."
				},
				{
					"name": "can_edit",
					"description": "Grants permission to edit the project."
				},
				{
					"name": "can_delete",
					"description": "Grants permission to delete the project."
				},
				{
					"name": "image_manager",
					"description": "Grants permission to create, view, edit, and delete all images belonging to the project."
				},
				{
					"name": "can_create_images",
					"description": "Grants permission to create images."
				},
				{
					"name": "can_view_images",
					"description": "Grants permission to view images."
				},
				{
					"name": "can_edit_images",
					"description": "Grants permission to edit images."
				},
				{
					"name": "can_delete_images",
					"description": "Grants permission to delete images."
				},
				{
					"name": "image_alias_manager",
					"description": "Grants permission to create, view, edit, and delete all image aliases belonging to the project."
				},
				{
					"name": "can_create_image_aliases",
					"description": "Grants permission to create image aliases."
				},
				{
					"name": "can_view_image_aliases",
					"description": "Grants permission to view image aliases."
				},
				{
					"name": "can_edit_image_aliases",
					"description": "Grants permission to edit image aliases."
				},
				{
					"name": "can_delete_image_aliases",
					"description": "Grants permission to delete image aliases."
				},
				{
					"name": "instance_manager",
					"description": "Grants permission to create, view, edit, and delete all instances belonging to the project."
				},
				{
					"name": "can_create_instances",
					"description": "Grants permission to create instances."
				},
				{
					"name": "can_view_instances",
					"description": "Grants permission to view instances."
				},
				{
					"name": "can_edit_instances",
					"description": "Grants permission to edit instances."
				},
				{
					"name": "can_delete_instances",
					"description": "Grants permission to delete instances."
				},
				{
					"name": "can_operate_instances",
					"description": "Grants permission to view instances, manage their state, manage their snapshots and backups, start terminal or console sessions, and access their files."
				},
				{
					"name": "network_manager",
					"description": "Grants permission to create, view, edit, and delete all networks belonging to the project."
				},
				{
					"name": "can_create_networks",
					"description": "Grants permission to create networks."
				},
				{
					"name": "can_view_networks",
					"description": "Grants permission to view networks."
				},
				{
					"name": "can_edit_networks",
					"description": "Grants permission to edit networks."
				},
				{
					"name": "can_delete_networks",
					"description": "Grants permission to delete networks."
				},
				{
					"name": "network_acl_manager",
					"description": "Grants permission to create, view, edit, and delete all network ACLs belonging to the project."
				},
				{
					"name": "can_create_network_acls",
					"description": "Grants permission to create network ACLs."
				},
				{
					"name": "can_view_network_acls",
					"description": "Grants permission to view network ACLs."
				},
				{
					"name": "can_edit_network_acls",
					"description": "Grants permission to edit network ACLs."
				},
				{
					"name": "can_delete_network_acls",
					"description": "Grants permission to delete network ACLs."
				},
				{
					"name": "network_zone_manager",
					"description": "Grants permission to create, view, edit, and delete all network zones belonging to the project."
				},
				{
					"name": "can_create_network_zones",
					"description": "Grants permission to create network zones."
				},
				{
					"name": "can_view_network_zones",
					"description": "Grants permission to view network zones."
				},
				{
					"name": "can_edit_network_zones",
					"description": "Grants permission to edit network zones."
				},
				{
					"name": "can_delete_network_zones",
					"description": "Grants permission to delete network zones."
				},
				{
					"name": "profile_manager",
					"description": "Grants permission to create, view, edit, and delete all profiles belonging to the project."
				},
				{
					"name": "can_create_profiles",
					"description": "Grants permission to create profiles."
				},
				{
					"name": "can_view_profiles",
					"description": "Grants permission to view profiles."
				},
				{
					"name": "can_edit_profiles",
					"description": "Grants permission to edit profiles."
				},
				{
					"name": "can_delete_profiles",
					"description": "Grants permission to delete profiles."
				},
				{
					"name": "storage_volume_manager",
					"description": "Grants permission to create, view, edit, and delete all storage volumes belonging to the project."
				},
				{
					"name": "can_create_storage_volumes",
					"description": "Grants permission to create storage volumes."
				},
				{
					"name": "can_view_storage_volumes",
					"description": "Grants permission to view storage volumes."
				},
				{
					"name": "can_edit_storage_volumes",
					"description": "Grants permission to edit storage volumes."
				},
				{
					"name": "can_delete_storage_volumes",
					"description": "Grants permission to delete storage volumes."
				},
				{
					"name": "storage_bucket_manager",
					"description": "Grants permission to create, view, edit, and delete all storage buckets belonging to the project."
				},
				{
					"name": "can_create_storage_buckets",
					"description": "Grants permission to create storage buckets."
				},
				{
					"name": "can_view_storage_buckets",
					"description": "Grants permission to view storage buckets."
				},
				{
					"name": "can_edit_storage_buckets",
					"description": "Grants permission to edit storage buckets."
				},
				{
					"name": "can_delete_storage_buckets",
					"description": "Grants permission to delete storage buckets."
				},
				{
					"name": "can_view_operations",
					"description": "Grants permission to view operations relating to the project."
				},
				{
					"name": "can_view_events",
					"description": "Grants permission to view events relating to the project."
				},
				{
					"name": "can_view_metrics",
					"description": "Grants permission to view project level metrics."
				}
			]
		},
		"server": {
			"project_specific": false,
			"entitlements": [
				{
					"name": "admin",
					"description": "Grants full access to LXD as if via Unix socket."
				},
				{
					"name": "viewer",
					"description": "Grants access to view all resources in the LXD server."
				},
				{
					"name": "can_edit",
					"description": "Grants permission to edit server configuration, to edit cluster member configuration, to update the state of a cluster member, to create, edit, and delete cluster groups, to update cluster member certificates, and to edit or delete warnings."
				},
				{
					"name": "permission_manager",
					"description": "Grants permission to view permissions, to create, edit, and delete identities, to view, create, edit, and delete authorization groups, and to view, create, edit, and delete identity provider groups. Note that clients with this permission are able to elevate their own privileges."
				},
				{
					"name": "can_view_permissions",
					"description": "Grants permission to view permissions."
				},
				{
					"name": "can_create_identities",
					"description": "Grants permission to create identities."
				},
				{
					"name": "can_view_identities",
					"description": "Grants permission to view identities."
				},
				{
					"name": "can_edit_identities",
					"description": "Grants permission to edit identities."
				},
				{
					"name": "can_delete_identities",
					"description": "Grants permission to delete identities."
				},
				{
					"name": "can_create_groups",
					"description": "Grants permission to create authorization groups."
				},
				{
					"name": "can_view_groups",
					"description": "Grants permission to view authorization groups."
				},
				{
					"name": "can_edit_groups",
					"description": "Grants permission to edit authorization groups."
				},
				{
					"name": "can_delete_groups",
					"description": "Grants permission to delete authorization groups."
				},
				{
					"name": "can_create_identity_provider_groups",
					"description": "Grants permission to create identity provider groups."
				},
				{
					"name": "can_view_identity_provider_groups",
					"description": "Grants permission to view identity provider groups."
				},
				{
					"name": "can_edit_identity_provider_groups",
					"description": "Grants permission to edit identity provider groups."
				},
				{
					"name": "can_delete_identity_provider_groups",
					"description": "Grants permission to delete identity provider groups."
				},
				{
					"name": "storage_pool_manager",
					"description": "Grants permission to create, edit, and delete storage pools."
				},
				{
					"name": "can_create_storage_pools",
					"description": "Grants permission to create storage pools."
				},
				{
					"name": "can_edit_storage_pools",
					"description": "Grants permission to edit storage pools."
				},
				{
					"name": "can_delete_storage_pools",
					"description": "Grants permission to delete storage pools."
				},
				{
					"name": "project_manager",
					"description": "Grants permission to view, create, edit, and delete projects, and to create, edit, and delete any resources that are owned by those projects."
				},
				{
					"name": "can_create_projects",
					"description": "Grants permission to create projects."
				},
				{
					"name": "can_view_projects",
					"description": "Grants permission to view projects, and all resources within those projects."
				},
				{
					"name": "can_edit_projects",
					"description": "Grants permission to edit projects, and all resources within those projects."
				},
				{
					"name": "can_delete_projects",
					"description": "Grants permission to delete projects."
				},
				{
					"name": "can_override_cluster_target_restriction",
					"description": "If a project is configured with `restricted.cluster.target`, clients with this permission can override the restriction."
				},
				{
					"name": "can_view_privileged_events",
					"description": "Grants permission to view privileged event types, such as logging events."
				},
				{
					"name": "can_view_resources",
					"description": "Grants permission to view server and storage pool resource usage information."
				},
				{
					"name": "can_view_metrics",
					"description": "Grants permission to view all server and project level metrics."
				},
				{
					"name": "can_view_warnings",
					"description": "Grants permission to view warnings."
				},
				{
					"name": "can_view_unmanaged_networks",
					"description": "Grants permission to view unmanaged networks on the LXD host machines."
				}
			]
		},
		"storage_bucket": {
			"project_specific": true,
			"entitlements": [
				{
					"name": "can_edit",
					"description": "Grants permission to edit the storage bucket."
				},
				{
					"name": "can_delete",
					"description": "Grants permission to delete the storage bucket."
				},
				{
					"name": "can_view",
					"description": "Grants permission to view the storage bucket."
				}
			]
		},
		"storage_pool": {
			"project_specific": false,
			"entitlements": [
				{
					"name": "can_edit",
					"description": "Grants permission to edit the storage pool."
				},
				{
					"name": "can_delete",
					"description": "Grants permission to delete the storage pool."
				}
			]
		},
		"storage_volume": {
			"project_specific": true,
			"entitlements": [
				{
					"name": "can_edit",
					"description": "Grants permission to edit the storage volume."
				},
				{
					"name": "can_delete",
					"description": "Grants permission to delete the storage volume."
				},
				{
					"name": "can_view",
					"description": "Grants permission to view the storage volume and any snapshots or backups it might have."
				},
				{
					"name": "can_manage_snapshots",
					"description": "Grants permission to create and delete snapshots of the storage volume."
				},
				{
					"name": "can_manage_backups",
					"description": "Grants permission to create and delete backups of the storage volume."
				}
			]
		}
	}
}